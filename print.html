<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>vhdMMIO</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="index.html"><strong aria-hidden="true">1.</strong> Index</a></li><li><a href="registerfileconfig.html"><strong aria-hidden="true">2.</strong> Register files</a></li><li><ol class="section"><li><a href="metadataconfig.html"><strong aria-hidden="true">2.1.</strong> Metadata</a></li><li><a href="featureconfig.html"><strong aria-hidden="true">2.2.</strong> Register file options</a></li><li><a href="entityconfig.html"><strong aria-hidden="true">2.3.</strong> VHDL entity configuration</a></li><li><a href="interfaceconfig.html"><strong aria-hidden="true">2.4.</strong> VHDL interface configuration</a></li><li><a href="fieldconfig.html"><strong aria-hidden="true">2.5.</strong> Field descriptors</a></li><li><ol class="section"><li><a href="primitive.html"><strong aria-hidden="true">2.5.1.</strong> primitive behavior</a></li><li><a href="constant.html"><strong aria-hidden="true">2.5.2.</strong> constant behavior</a></li><li><a href="config.html"><strong aria-hidden="true">2.5.3.</strong> config behavior</a></li><li><a href="status.html"><strong aria-hidden="true">2.5.4.</strong> status behavior</a></li><li><a href="internalstatus.html"><strong aria-hidden="true">2.5.5.</strong> internal-status behavior</a></li><li><a href="latching.html"><strong aria-hidden="true">2.5.6.</strong> latching behavior</a></li><li><a href="control.html"><strong aria-hidden="true">2.5.7.</strong> Control</a></li><li><a href="internalcontrol.html"><strong aria-hidden="true">2.5.8.</strong> internal-control behavior</a></li><li><a href="flag.html"><strong aria-hidden="true">2.5.9.</strong> flag behavior</a></li><li><a href="volatileflag.html"><strong aria-hidden="true">2.5.10.</strong> volatile-flag behavior</a></li><li><a href="internalflag.html"><strong aria-hidden="true">2.5.11.</strong> internal-flag behavior</a></li><li><a href="volatileinternalflag.html"><strong aria-hidden="true">2.5.12.</strong> volatile-internal-flag behavior</a></li><li><a href="strobe.html"><strong aria-hidden="true">2.5.13.</strong> strobe behavior</a></li><li><a href="internalstrobe.html"><strong aria-hidden="true">2.5.14.</strong> internal-strobe behavior</a></li><li><a href="request.html"><strong aria-hidden="true">2.5.15.</strong> request behavior</a></li><li><a href="multirequest.html"><strong aria-hidden="true">2.5.16.</strong> multi-request behavior</a></li><li><a href="counter.html"><strong aria-hidden="true">2.5.17.</strong> counter behavior</a></li><li><a href="volatilecounter.html"><strong aria-hidden="true">2.5.18.</strong> volatile-counter behavior</a></li><li><a href="internalcounter.html"><strong aria-hidden="true">2.5.19.</strong> internal-counter behavior</a></li><li><a href="volatileinternalcounter.html"><strong aria-hidden="true">2.5.20.</strong> volatile-internal-counter behavior</a></li><li><a href="streamtommio.html"><strong aria-hidden="true">2.5.21.</strong> stream-to-mmio behavior</a></li><li><a href="mmiotostream.html"><strong aria-hidden="true">2.5.22.</strong> mmio-to-stream behavior</a></li><li><a href="axi.html"><strong aria-hidden="true">2.5.23.</strong> axi behavior</a></li><li><a href="interrupt.html"><strong aria-hidden="true">2.5.24.</strong> interrupt behavior</a></li><li><a href="interruptflag.html"><strong aria-hidden="true">2.5.25.</strong> interrupt-flag behavior</a></li><li><a href="volatileinterruptflag.html"><strong aria-hidden="true">2.5.26.</strong> volatile-interrupt-flag behavior</a></li><li><a href="interruptpend.html"><strong aria-hidden="true">2.5.27.</strong> interrupt-pend behavior</a></li><li><a href="interruptenable.html"><strong aria-hidden="true">2.5.28.</strong> interrupt-enable behavior</a></li><li><a href="interruptunmask.html"><strong aria-hidden="true">2.5.29.</strong> interrupt-unmask behavior</a></li><li><a href="interruptstatus.html"><strong aria-hidden="true">2.5.30.</strong> interrupt-status behavior</a></li><li><a href="interruptraw.html"><strong aria-hidden="true">2.5.31.</strong> interrupt-raw behavior</a></li><li><a href="custom.html"><strong aria-hidden="true">2.5.32.</strong> custom behavior</a></li><li><ol class="section"><li><a href="custominterfaceconfig.html"><strong aria-hidden="true">2.5.32.1.</strong> Interfaces for custom field behavior</a></li></ol></li><li><a href="conditionconfig.html"><strong aria-hidden="true">2.5.33.</strong> Additional address match conditions</a></li><li><a href="subaddressconfig.html"><strong aria-hidden="true">2.5.34.</strong> Subaddress components</a></li><li><a href="permissionconfig.html"><strong aria-hidden="true">2.5.35.</strong> Permissions</a></li></ol></li><li><a href="interruptconfig.html"><strong aria-hidden="true">2.6.</strong> Interrupt descriptors</a></li><li><a href="internalioconfig.html"><strong aria-hidden="true">2.7.</strong> Internal signal I/O</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">vhdMMIO</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#vhdmmio" id="vhdmmio"><h1><code>vhdmmio</code></h1></a>
<p><code>vhdmmio</code> concerns itself with the generation of register files. To
<code>vhdmmio</code>, a register file is an AXI4-lite slave, consisting of any number
of fields, occupying the full 4GiB address range provided by AXI4-lite for
as far as the register file is concerned. Normally, not the whole 4GiB
range will be accessible; this is up to the unit that's generating the
addresses. For the &quot;toplevel&quot; register file, this would normally be some
shell or bus infrastructure that only maps a certain address range to it.</p>
<p><code>vhdmmio</code> does not provide any bus infrastructure blocks such as address
decoders/demuxers. Nevertheless, it is possible to connect multiple
register files together in a hierarchical way; one of the field types
<code>vhdmmio</code> provides behaves like an AXI4-lite passthrough.</p>
<p>Each register file maps to a single VHDL entity and an accompanying
support package for the component declaration and type definitions needed
for the ports. There is also a common support package (<code>vhdmmio_pkg.vhd</code>)
that defines shared data types, most importantly the AXI4-lite records that
<code>vhdmmio</code> uses on the entity interfaces (intended to save you a whole lot
of typing when connecting stuff together).</p>
<p>Because of the above, register files in a design are largely independent.
However, AXI4-Lite passthrough fields can refer to other register files in
the design to indicate how the register files are hooked up in the design.
<code>vhdmmio</code> can/will be able to use this information to generate more
complete documentation, and to generate C(++) header files/classes and
Python classes for accessing the register file hierarchy as a whole.</p>
<p>The generated register files are human-readable, so if you need to debug or
change something after generation, you should be able to. The entities
consist of a single one-process-style FSM that use variables for state
information, so for debugging you'll need a tool that can trace variables.
Note that this code style implies that all output ports of <code>vhdmmio</code>
generated entities are register outputs. This should help a little with
timing closure, but the register files are not intended to be clocked
insanely high. If your active logic requires a high clock speed and
<code>vhdmmio</code>'s register files can't keep up, consider a multi-clock design.</p>
<a class="header" href="#table-of-contents" id="table-of-contents"><h1>Table of contents</h1></a>
<ul>
<li><a href="registerfileconfig.html">Register files</a>
<ul>
<li><a href="metadataconfig.html">Metadata</a></li>
<li><a href="featureconfig.html">Register file options</a></li>
<li><a href="entityconfig.html">VHDL entity configuration</a></li>
<li><a href="interfaceconfig.html">VHDL interface configuration</a></li>
<li><a href="fieldconfig.html">Field descriptors</a>
<ul>
<li><a href="primitive.html"><code>primitive</code> behavior</a></li>
<li><a href="constant.html"><code>constant</code> behavior</a></li>
<li><a href="config.html"><code>config</code> behavior</a></li>
<li><a href="status.html"><code>status</code> behavior</a></li>
<li><a href="internalstatus.html"><code>internal-status</code> behavior</a></li>
<li><a href="latching.html"><code>latching</code> behavior</a></li>
<li><a href="control.html"><code>Control</code></a></li>
<li><a href="internalcontrol.html"><code>internal-control</code> behavior</a></li>
<li><a href="flag.html"><code>flag</code> behavior</a></li>
<li><a href="volatileflag.html"><code>volatile-flag</code> behavior</a></li>
<li><a href="internalflag.html"><code>internal-flag</code> behavior</a></li>
<li><a href="volatileinternalflag.html"><code>volatile-internal-flag</code> behavior</a></li>
<li><a href="strobe.html"><code>strobe</code> behavior</a></li>
<li><a href="internalstrobe.html"><code>internal-strobe</code> behavior</a></li>
<li><a href="request.html"><code>request</code> behavior</a></li>
<li><a href="multirequest.html"><code>multi-request</code> behavior</a></li>
<li><a href="counter.html"><code>counter</code> behavior</a></li>
<li><a href="volatilecounter.html"><code>volatile-counter</code> behavior</a></li>
<li><a href="internalcounter.html"><code>internal-counter</code> behavior</a></li>
<li><a href="volatileinternalcounter.html"><code>volatile-internal-counter</code> behavior</a></li>
<li><a href="streamtommio.html"><code>stream-to-mmio</code> behavior</a></li>
<li><a href="mmiotostream.html"><code>mmio-to-stream</code> behavior</a></li>
<li><a href="axi.html"><code>axi</code> behavior</a></li>
<li><a href="interrupt.html"><code>interrupt</code> behavior</a></li>
<li><a href="interruptflag.html"><code>interrupt-flag</code> behavior</a></li>
<li><a href="volatileinterruptflag.html"><code>volatile-interrupt-flag</code> behavior</a></li>
<li><a href="interruptpend.html"><code>interrupt-pend</code> behavior</a></li>
<li><a href="interruptenable.html"><code>interrupt-enable</code> behavior</a></li>
<li><a href="interruptunmask.html"><code>interrupt-unmask</code> behavior</a></li>
<li><a href="interruptstatus.html"><code>interrupt-status</code> behavior</a></li>
<li><a href="interruptraw.html"><code>interrupt-raw</code> behavior</a></li>
<li><a href="custom.html"><code>custom</code> behavior</a>
<ul>
<li><a href="custominterfaceconfig.html">Interfaces for <code>custom</code> field behavior</a></li>
</ul>
</li>
<li><a href="conditionconfig.html">Additional address match conditions</a></li>
<li><a href="subaddressconfig.html">Subaddress components</a></li>
<li><a href="permissionconfig.html">Permissions</a></li>
</ul>
</li>
<li><a href="interruptconfig.html">Interrupt descriptors</a></li>
<li><a href="internalioconfig.html">Internal signal I/O</a></li>
</ul>
</li>
</ul>
<a class="header" href="#register-files" id="register-files"><h1>Register files</h1></a>
<p>This is the root configuration structure for <code>vhdmmio</code> register
files.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#metadata" id="metadata"><h2><code>metadata</code></h2></a>
<p>This configuration structure is used to name and document the
register file.</p>
<p>This key must be set to a dictionary. Its structure is defined <a href="metadataconfig.html">here</a>. Not specifying the key is equivalent to specifying an empty dictionary.</p>
<a class="header" href="#features" id="features"><h2><code>features</code></h2></a>
<p>This configuration structure is used to specify some options that
affect register file as a whole.</p>
<p>This key must be set to a dictionary. Its structure is defined <a href="featureconfig.html">here</a>. Not specifying the key is equivalent to specifying an empty dictionary.</p>
<a class="header" href="#entity" id="entity"><h2><code>entity</code></h2></a>
<p>This configuration structure is used to configure how the MMIO
entity is generated.</p>
<p>This key must be set to a dictionary. Its structure is defined <a href="entityconfig.html">here</a>. Not specifying the key is equivalent to specifying an empty dictionary.</p>
<a class="header" href="#interface" id="interface"><h2><code>interface</code></h2></a>
<p>This key specifies the default VHDL entity interface generation
options for fields and interrupts alike.</p>
<p>This key must be set to a dictionary. Its structure is defined <a href="interfaceconfig.html">here</a>. Not specifying the key is equivalent to specifying an empty dictionary.</p>
<a class="header" href="#fields" id="fields"><h2><code>fields</code></h2></a>
<p>This key describes the fields that the register file contains.</p>
<p>This key must be set to a list of dictionaries, of which the structure is defined <a href="fieldconfig.html">here</a>. In addition, the <code>subfields</code> key can be used to define the list elements as a tree; if it is present in one of the dictionaries, the dictionary becomes a non-leaf node, with the <code>subfields</code> key specifying the list of child nodes. This tree is flattened during parsing, in such a way that the configuration for a flattened node becomes the root dictionary, updated with its child dictionary, all the way down to the leaf node; the non-leaf nodes essentially set the default values for their children. For example,</p>
<pre><code>fields:
- a: 1
  b: 2
  c: 3
  subfields:
  - a: 5
  - d: 4
</code></pre>
<p>is equivalent to</p>
<pre><code>fields:
- a: 5
  b: 2
  c: 3
- a: 1
  b: 2
  c: 3
  d: 4
</code></pre>
<p>This can be useful for specifying repetetive structures.</p>
<p>This key is optional. Not specifying it is equivalent to specifying an empty list.</p>
<a class="header" href="#interrupts" id="interrupts"><h2><code>interrupts</code></h2></a>
<p>This key describes the interrupts that the register file
contains.</p>
<p>This key must be set to a list of dictionaries, of which the structure is defined <a href="interruptconfig.html">here</a>.</p>
<p>This key is optional. Not specifying it is equivalent to specifying an empty list.</p>
<a class="header" href="#internal-io" id="internal-io"><h2><code>internal-io</code></h2></a>
<p>This configuration structure can be used to expose internal signals
to the VHDL entity's interface, essentially making them external.</p>
<p>This key must be set to a list of dictionaries, of which the structure is defined <a href="internalioconfig.html">here</a>.</p>
<p>This key is optional. Not specifying it is equivalent to specifying an empty list.</p>
<a class="header" href="#metadata-1" id="metadata-1"><h1>Metadata</h1></a>
<p>This configuration structure is used to identify and document objects
within <code>vhdmmio</code>.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#mnemonic" id="mnemonic"><h2><code>mnemonic</code></h2></a>
<p>The mnemonic of the object. Mnemonics are usually very short,
uppercase identifiers, idiomatically used within register file
descriptions. <code>vhdmmio</code> requires that they are unique within the
current context only; that is, two fields in a single logical
register cannot have the same mnemonic, but if they were in different
logical registers this would be fine. However, chains of mnemonics
separated by underscores must still be unique. For instance, it's
illegal to have a register <code>X</code> containing field <code>Y_Z</code> and another
register <code>X_Y</code> containing field <code>Z</code>.</p>
<p>If the mnemonic names an array, it cannot end in a number, since the
array index is added to the mnemonic in various contexts.</p>
<p>If no mnemonic is specified, it is generated from the name by simply
uppercasing it. Either name, mnemonic, or both must be specified.</p>
<p>This key is optional unless required by context.</p>
<a class="header" href="#name" id="name"><h2><code>name</code></h2></a>
<p>The name of the object. Names are generally longer and more
descriptive than mnemonics, but also need to be more unique; no two
fields within a register file can have the same name. Matching is
case-insensitive since VHDL is case-insensitive, but <code>vhdmmio</code> never
changes the case of a name.</p>
<p>Like mnemonics, if the name names an array, it cannot end in a number,
since the array index is added to the name in various contexts.</p>
<p>If no name is specified, it is generated from the mnemonic by simply
lowercasing it. Either name, mnemonic, or both must be specified.</p>
<p>This key is optional unless required by context.</p>
<a class="header" href="#brief" id="brief"><h2><code>brief</code></h2></a>
<p>A brief, one-line description of the object. This will be rendered
as markdown in the documentation output. Idiomatically, the brief
description should start with a lowercase letter and end in a period,
so it looks good when used in a list like <code>&quot;&lt;name&gt;: &lt;brief&gt;&quot;</code>. The
brief may also be used as a standalone sentence; in this case, the
first letter is automatically uppercased. When printed in source code
comments, the description is automatically wrapped to an appropriate
line length. All spacing characters, including newlines, are collapsed
into a single space before the brief is used.</p>
<p>Brief documentation may be printed once for an array of fields or for
each field index independently depending on context. To this end,
the magic string <code>{index}</code> is replaced with the index or range as
required by context:</p>
<ul>
<li>If the object is not an array, it is replaced with an empty string.</li>
<li>If the object is an array and the brief refers to the entire array
or a slice thereof, it is replaced with <code>&lt;low&gt;..&lt;high&gt;</code>.</li>
<li>If the object is an array and the brief refers to a single index,
it is simply replaced with just that index.</li>
</ul>
<p>This key is optional unless required by context.</p>
<a class="header" href="#doc" id="doc"><h2><code>doc</code></h2></a>
<p>Extended documentation for the object. This is only used for
documentation output, and can therefore be any valid markdown. However,
avoid using <code>----</code> and <code>====</code> underlining for headers; instead use the
<code>#</code> prefix notation. <code>vhdmmio</code> will automatically prefix such headers
with additional hashes to get to the right header level. The brief
documentation is always added as a single paragraph before the extended
documentation.</p>
<p>Like the brief documentation, extended documentation may be printed
once for an array of fields or for each field index independently
depending on context. Therefore, <code>{index}</code> is replaced for <code>doc</code> in
exactly the same way.</p>
<p>This key is optional unless required by context.</p>
<a class="header" href="#register-file-options" id="register-file-options"><h1>Register file options</h1></a>
<p>This configuration structure specifies some miscellaneous options that
affect the functionality and generation of the register file as a whole.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#bus-width" id="bus-width"><h2><code>bus-width</code></h2></a>
<p>This key specifies the width of the generated AXI4-lite slave
bus.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>32</code> (default): the bus uses 32-bit data words.</p>
</li>
<li>
<p><code>64</code>: the bus uses 64-bit data words.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>32</code>) is used.</p>
<a class="header" href="#endianness" id="endianness"><h2><code>endianness</code></h2></a>
<p>This key specifies the default endianness used for multi-block
fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>little</code> (default): the default is little endian. That is, when multiple blocks are needed to describe the field(s), bit 0 of the register resides in the <em>first</em> block.</p>
</li>
<li>
<p><code>big</code>: the default is big endian. That is, when multiple blocks are needed to describe the field(s), bit 0 of the register resides in the <em>last</em> block.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>little</code>) is used.</p>
<a class="header" href="#max-outstanding" id="max-outstanding"><h2><code>max-outstanding</code></h2></a>
<p>This key specifies the maximum number of outstanding requests per
operation (read/write) for fields that support this. This value is
essentially the depth of a FIFO that stores the order in which
supporting fields were accessed. Since the width of the FIFO is the
2log of the number of supporting fields, the depth configuration has
very little effect if there is only one such field (everything but the
FIFO control logic will be optimized away) and no effect if there is
no such field.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>16</code> (default): there can be up to 16 outstanding requests.</p>
</li>
<li>
<p>an integer above or equal to 2: there can be up to this many outstanding requests.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>16</code>) is used.</p>
<a class="header" href="#insecure" id="insecure"><h2><code>insecure</code></h2></a>
<p>This key allows you to disable the multi-word register protection
features normally inferred by <code>vhdmmio</code> when any of the fields in the
register file are sensitive to <code>aw_prot</code> or <code>ar_prot</code>. This may save
some area. More information about <code>vhdmmio</code>'s security features is
available <a href="permissionconfig.html">here</a>.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#optimize" id="optimize"><h2><code>optimize</code></h2></a>
<p>Normally, <code>vhdmmio</code> infers address comparators that match <em>all</em> word
address bits in the incoming request to the field bitranges, such that
decode errors are properly generated. This can be quite costly in terms
of area and timing however, since in the worst case each register will
get its own 30-bit address comparator. Setting this flag to <code>yes</code>
allows <code>vhdmmio</code> to assign undefined behavior to unused addresses,
which lets it minimize the width of these comparators.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#vhdl-entity-configuration" id="vhdl-entity-configuration"><h1>VHDL entity configuration</h1></a>
<p>This configuration structure can be used to configure the common
interfaces of the generated entity, such as the bus and the clock.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#clock-name" id="clock-name"><h2><code>clock-name</code></h2></a>
<p>This key specifies the name of the clock input port. The clock is
always rising-edge-sensitive.</p>
<p>The value must be a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code> (default <code>clk</code>): name of the clock input port.</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>clk</code>) is used.</p>
<a class="header" href="#reset-name" id="reset-name"><h2><code>reset-name</code></h2></a>
<p>This key specifies the name of the reset input port. The reset input
is always synchronous, but can be set to either active-high or
active-low using the <code>reset-active</code> parameter. The default <code>reset</code> name
can only be used when the reset is active-high due to limitations in
the template; it is suggested to suffix an <code>n</code> when the reset signal is
active-low to avoid this problem.</p>
<p>The value must be a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code> (default <code>reset</code>): name of the reset input port.</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>reset</code>) is used.</p>
<a class="header" href="#reset-active" id="reset-active"><h2><code>reset-active</code></h2></a>
<p>This key specifies for which signal level the reset signal is
considered to be asserted.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>high</code> (default): the reset signal is active-high.</p>
</li>
<li>
<p><code>low</code>: the reset signal is active-low. The default <code>reset</code> port name cannot be used.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>high</code>) is used.</p>
<a class="header" href="#bus-prefix" id="bus-prefix"><h2><code>bus-prefix</code></h2></a>
<p>This key specifies the prefix used for the AXI4-lite bus signals,
including underscore separator if one is desired. When the bus is not
flattened, the signals <code>&lt;prefix&gt;i</code> and <code>&lt;prefix&gt;o</code> are generated. When
flattened, the standard names for the AXI4-lite interface channels are
suffixed:</p>
<ul>
<li>Write address channel: <code>awvalid</code>, <code>awready</code>, <code>awaddr</code> and <code>awprot</code>;</li>
<li>Write data channel: <code>wvalid</code>, <code>wready</code>, <code>wdata</code>, and <code>wstrb</code>;</li>
<li>Write response channel: <code>bvalid</code>, <code>bready</code>, and <code>bresp</code>;</li>
<li>Read address channel: <code>arvalid</code>, <code>arready</code>, <code>araddr</code>, and <code>arprot</code>;</li>
<li>Read data channel: <code>rvalid</code>, <code>rready</code>, <code>rdata</code>, and <code>rresp</code>.</li>
</ul>
<p>The value must be a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code> (default <code>bus_</code>): prefix for the bus ports.</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>bus_</code>) is used.</p>
<a class="header" href="#bus-flatten" id="bus-flatten"><h2><code>bus-flatten</code></h2></a>
<p>This key specifies whether records or flattened signals are desired
for the bus interface.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the bus is not flattened; the records from <code>vhdmmio_pkg.vhd</code> are used.</p>
</li>
<li>
<p><code>yes</code>: the bus is flattened; the standard AXI4-lite signal names are used.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#vhdl-interface-configuration" id="vhdl-interface-configuration"><h1>VHDL interface configuration</h1></a>
<p>Each field and interrupt in <code>vhdmmio</code> can register scalar and vector
inputs and outputs, as well as generics. This configuration structure
determines how these interfaces are exposed in the entity.</p>
<p>By default, the ports are grouped by field/interrupt into records while
generics are flattened, but either can be overridden. It is also possible
to group multiple fields/interrupts together in a single record.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#group" id="group"><h2><code>group</code></h2></a>
<p>Name of the group record used for ports, if any. The ports for any
objects that share the same non-null <code>group</code> tag are combined into a
single record pair (<code>in</code> and <code>out</code>).</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): port grouping is determined by the global default.</p>
</li>
<li>
<p><code>no</code>: ports are not grouped in an additional record.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: ports are grouped in a record with the specified name.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#flatten" id="flatten"><h2><code>flatten</code></h2></a>
<p>Whether the ports for this object should be flattened or combined in
a record (pair).</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): port flattening is determined by the global default.</p>
</li>
<li>
<p><code>no</code>: all ports needed for this object are combined in a record specific to the object. If <code>group</code> is specified in addition, there will be two levels of records. For arrays, an array of records is created.</p>
</li>
<li>
<p><code>record</code>: The record mentioned above is flattened out. For array objects, <code>std_logic</code> ports become <code>std_logic_array</code>s (ascending range), and <code>std_logic_vector</code> ports become an array (ascending range) of an appropriately sized <code>std_logic_vector</code>.</p>
</li>
<li>
<p><code>yes</code>: All port types are flattened to <code>std_logic</code>s or <code>std_logic_vector</code>s. <code>std_logic_vector</code> ports for array objects are simply concatenated using the customary descending range, with the lowest-indexed field in the least-significant position.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#generic-group" id="generic-group"><h2><code>generic-group</code></h2></a>
<p>Same as <code>group</code>, but for generics.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): generic grouping is determined by the global default.</p>
</li>
<li>
<p><code>no</code>: generics are not grouped in an additional record.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: generics are grouped in a record with the specified name.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#generic-flatten" id="generic-flatten"><h2><code>generic-flatten</code></h2></a>
<p>Same as <code>flatten</code>, but for generics.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): generic flattening is determined by the global default.</p>
</li>
<li>
<p><code>record</code>: generics are not grouped in a record, but arrays remain regular arrays (possibly of <code>std_logic_vector</code>s).</p>
</li>
<li>
<p><code>yes</code>: as above, but all <code>std_logic</code>-based generics are flattened to single <code>std_logic</code>s or std_logic_vector`s. Other primitive types still receive their own custom array type for array objects.</p>
</li>
<li>
<p><code>no</code>: all generics needed for this object are combined in a record specific to the object.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#field-descriptors" id="field-descriptors"><h1>Field descriptors</h1></a>
<p>A field descriptor describes either a single field or an array of
fields. Each field produced by a field descriptor has exactly the same
characteristics, but maps to a different bitrange, and uses a different
array index on the register file interface. These bitranges are described
by means of a base bitrange (<code>bitrange</code>, optionally offset by <code>address</code>), a
repeat count (<code>repeat</code>) and the necessary strides (<code>stride</code>, <code>field-stride</code>
and <code>field-repeat</code>). Such repetition is useful when you have an array of
similar registers, for instance in a DMA controller with multiple channels,
where each channel has its own set of status and control flags.</p>
<p>Note that this means that you can have four kinds of field descriptors:</p>
<ul>
<li>singular scalar fields,</li>
<li>singular vector fields,</li>
<li>repeated/array scalar fields, and</li>
<li>repeated/array vector fields.</li>
</ul>
<p>In the VHDL world, scalar vs. vector is distinguished by the base type used
for interface signals: <code>std_logic</code> for scalar, and
<code>std_logic_vector(N-1 downto 0)</code> for vectors. By default, ports that belong
to the same field are gathered into a record. This record in turn becomes
an array of records for repeated fields, indexed using <code>(0 to N-1)</code>. This
record and/or the arrays of <code>std_logic_vector</code>s can be flattened away if
needed using the <code>interface</code> structure.</p>
<p>The fields themselves as well as the registers they reside in have
identifiers and documentation attachted to them (<code>mnemonic</code>, <code>name</code>,
<code>brief</code>, <code>doc</code>, <code>register-*</code>). These are obviously used for documentation
generation, but also in the generated code in various ways, depending on
the language backend used. A zero-indexed integer suffix is automatically
added for arrays of fields.</p>
<a class="header" href="#behavior" id="behavior"><h2>Behavior</h2></a>
<p>The behavior of the field is determined by the <code>behavior</code> key and
associated configuration. There are predefined behaviors for a lot of
functions commonly and less commonly seen in commercial peripheral register
files. On rare occasions where none of the predefined behaviors fit what
you need, you can use the <code>custom</code> behavior, which lets you specify the
field-specific VHDL code directly.</p>
<p>Access to the field can optionally be denied based on the AXI4L <code>aw_prot</code>
and <code>ar_prot</code> fields (<code>read-deny</code> and <code>write-deny</code>). The VHDL code
generated for the field can be further customized using the <code>interface</code>
key.</p>
<p>Field behaviors can be read-write, read-only, or write-only. Read-only
fields can overlap with write-only fields.</p>
<a class="header" href="#logical-registers-and-blocks" id="logical-registers-and-blocks"><h2>Logical registers and blocks</h2></a>
<p>When parsing a register file description, <code>vhdmmio</code> flattens the field
descriptors into fields, and then groups them again by address and
operation (read/write). Such groups are called logical registers.</p>
<p>It is important to note here that even though each field essentially
describes the shape of the logical register that surrounds it using the
addressing keys, logical registers cannot overlap. The only exception
is that a logical register with only write-only fields can overlap/differ
from a logical register with only read-only fields.</p>
<p>A logical register consists of one or more blocks. A block is a single
addressable unit, consisting of a base addess and a mask. The mask allows
the block to be bigger than a single bus word, by ignoring one or more
bits in the comparison. Some field behaviors use these ignored bits for
purposes other than address matching; for example, the AXI passthrough
behavior uses them to construct the downstream bus addresses.</p>
<p>Multiple blocks are assigned to a logical register when it has fields
mapped to it with bit indices beyond the width of the bus; the higher-order
bits carry over into a neighboring block until all fields have a place.
Either little- or big-endian mode can be specified for this; in
little-endian mode the LSB of the logical register resides in the first
block, while in big-endian mode the MSB resides in the first block.</p>
<p>The addresses of the blocks are computed by binary-incrementing the
non-masked bits address. For example, if the base address for a field is
specified to end with binary <code>10--10--</code>, consecutive blocks will be at
addresses <code>10--11--</code>, <code>11--00--</code>, <code>11--01--</code>, and so on.</p>
<a class="header" href="#atomic-access-to-multi-block-registers" id="atomic-access-to-multi-block-registers"><h2>Atomic access to multi-block registers</h2></a>
<p><code>vhdmmio</code> ensures that logical registers that span multiple blocks are
accessed atomically by means of holding registers. It does so by inferring
central read/write holding registers as large as the largest logical
register in the register file minus the bus width. For reads, reading from
the first block actually performs the read, delivering the low/high word to
the bus immediately (little-/big-endian), and saving the rest in the read
holding register. Reads to the subsequent blocks simply return whatever is
in the holding register. The inverse is done for writes: writing to the
last block actually performs the write, while the preceding accesses write
the data and strobe signals to the write holding register.</p>
<p>The advantage of sharing holding registers is that it reduces the size of
the address decoder and read multiplexer; many addresses taking data from
the same source is advantageous for both area and timing. The primary
disadvantage is that it only works properly when the blocks are accessed
sequentially and completely. It is up to the bus master to enforce this; if
it fails to do so, accesses may end up reading or writing garbage. You can
therefore generally NOT mix purely AXI4L multi-master systems with
multi-block registers.</p>
<p>If you need both multi-block registers and have multiple masters, either
use full AXI4 arbiters and use the <code>ar_lock</code>/<code>aw_lock</code> signals
appropriately, ensure mutually-exclusive access by means of software
solutions, or implement the desired behavior yourself. The necessary write
holding registers are essentially just <code>control</code> fields, while the read
holding registers are <code>latching</code> fields.</p>
<p>Multi-block registers with shared holding registers also has security
implications: a malicious piece of code may intentionally try to violate
the aforementioned assumptions to manipulate or eavesdrop accesses made
by another program/bus master. This is particularly important when the
AXI4L <code>aw_prot</code> or <code>ar_prot</code> signals are used to restrict access to
certain fields. More information on this subject can be found
<a href="permissionconfig.html">here</a>.</p>
<a class="header" href="#configuration-keys" id="configuration-keys"><h2>Configuration keys</h2></a>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#behavior-1" id="behavior-1"><h2><code>behavior</code></h2></a>
<p>This key describes the behavior of this field or array of fields.</p>
<p>This key can take the following values:</p>
<ul>
<li>
<p><a href="primitive.html"><code>primitive</code></a>: base class for regular field behavior. Normally not used directly; it's easier to use one of its specializations:</p>
<ul>
<li>
<p>Constant fields for reading the design-time configuration of the hardware:</p>
<ul>
<li>
<p><a href="constant.html"><code>constant</code></a>: field which always reads as the same constant value.</p>
</li>
<li>
<p><a href="config.html"><code>config</code></a>: field which always reads as the same value, configured through a generic.</p>
</li>
</ul>
</li>
<li>
<p>Status fields for monitoring hardware:</p>
<ul>
<li>
<p><a href="status.html"><code>status</code></a>: field which always reflects the current state of an incoming signal.</p>
</li>
<li>
<p><a href="internalstatus.html"><code>internal-status</code></a>: field which always reflects the current state of an internal signal.</p>
</li>
<li>
<p><a href="latching.html"><code>latching</code></a>: status field that is only updated by hardware when a write-enable flag is set.</p>
</li>
</ul>
</li>
<li>
<p>Control fields for configuring hardware:</p>
<ul>
<li>
<p><a href="control.html"><code>control</code></a>: basic control field, i.e. written by software and read by hardware.</p>
</li>
<li>
<p><a href="internalcontrol.html"><code>internal-control</code></a>: like <code>control</code>, but drives an internal signal.</p>
</li>
</ul>
</li>
<li>
<p>Flag-like fields for signalling events from hardware to software:</p>
<ul>
<li>
<p><a href="flag.html"><code>flag</code></a>: one flag per bit, set by hardware and explicitly cleared by an MMIO write.</p>
</li>
<li>
<p><a href="volatileflag.html"><code>volatile-flag</code></a>: like <code>flag</code>, but implicitly cleared on read.</p>
</li>
<li>
<p><a href="internalflag.html"><code>internal-flag</code></a>: like <code>flag</code>, but set by an internal signal.</p>
</li>
<li>
<p><a href="volatileinternalflag.html"><code>volatile-internal-flag</code></a>: combination of <code>volatile-flag</code> and <code>internal-flag</code>.</p>
</li>
</ul>
</li>
<li>
<p>Flag-like fields for signalling requests from software to hardware:</p>
<ul>
<li>
<p><a href="strobe.html"><code>strobe</code></a>: one flag per bit, strobed by an MMIO write to signal some request to hardware.</p>
</li>
<li>
<p><a href="internalstrobe.html"><code>internal-strobe</code></a>: one flag per bit, strobed by an MMIO write to signal some request to another <code>vhdmmio</code> construct.</p>
</li>
<li>
<p><a href="request.html"><code>request</code></a>: like <code>strobe</code>, but the request flags stay high until acknowledged by hardware.</p>
</li>
<li>
<p><a href="multirequest.html"><code>multi-request</code></a>: allows multiple software-to-hardware requests to be queued up atomically by counting.</p>
</li>
</ul>
</li>
<li>
<p>Fields for counting events:</p>
<ul>
<li>
<p><a href="counter.html"><code>counter</code></a>: external event counter, reset explicitly by a write.</p>
</li>
<li>
<p><a href="volatilecounter.html"><code>volatile-counter</code></a>: external event counter, reset implicitly by the read.</p>
</li>
<li>
<p><a href="internalcounter.html"><code>internal-counter</code></a>: internal event counter, reset explicitly by a write.</p>
</li>
<li>
<p><a href="volatileinternalcounter.html"><code>volatile-internal-counter</code></a>: internal event counter, reset implicitly by the read.</p>
</li>
</ul>
</li>
<li>
<p>Fields for interfacing with AXI streams:</p>
<ul>
<li>
<p><a href="streamtommio.html"><code>stream-to-mmio</code></a>: field which pops data from an incoming stream.</p>
</li>
<li>
<p><a href="mmiotostream.html"><code>mmio-to-stream</code></a>: field which pushes data into an outgoing stream.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Fields for interfacing with AXI4-lite busses:</p>
<ul>
<li><a href="axi.html"><code>axi</code></a>: connects a field to an AXI4-lite master port for generating hierarchical bus structures.</li>
</ul>
</li>
<li>
<p>Fields for controlling <code>vhdmmio</code>-managed interrupts:</p>
<ul>
<li>
<p><a href="interrupt.html"><code>interrupt</code></a>: base class for interrupt field behaviors. Normally not used directly; it's easier to use one of its specializations:</p>
</li>
<li>
<p><a href="interruptflag.html"><code>interrupt-flag</code></a>: interrupt pending flag, cleared by writing ones.</p>
</li>
<li>
<p><a href="volatileinterruptflag.html"><code>volatile-interrupt-flag</code></a>: interrupt pending flag, cleared by reading.</p>
</li>
<li>
<p><a href="interruptpend.html"><code>interrupt-pend</code></a>: software-pend field.</p>
</li>
<li>
<p><a href="interruptenable.html"><code>interrupt-enable</code></a>: interrupt enable control field.</p>
</li>
<li>
<p><a href="interruptunmask.html"><code>interrupt-unmask</code></a>: interrupt unmask control field.</p>
</li>
<li>
<p><a href="interruptstatus.html"><code>interrupt-status</code></a>: reflects the masked interrupt flag.</p>
</li>
<li>
<p><a href="interruptraw.html"><code>interrupt-raw</code></a>: reflects the raw interrupt request.</p>
</li>
</ul>
</li>
<li>
<p><a href="custom.html"><code>custom</code></a>: allows you to specify the field-specific VHDL code manually.</p>
</li>
</ul>
<p>Depending on the value, additional configuration keys may be supported or required. These must be specified in the same dictionary that this key resides in. Refer to the documentation for the individual values for more information.</p>
<a class="header" href="#address" id="address"><h2><code>address</code></h2></a>
<p>This key specifies the base address and block mask for the logical
register that the first field described by this descriptor resides
in.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p>an integer above or equal to 0: specifies the byte address. The address LSBs that index bytes within the bus word are ignored per the AXI4L specification.</p>
</li>
<li>
<p>a hex/bin integer with don't cares: as before, but specified as a string representation of a hexadecimal or binary integer which may contain don't cares (<code>-</code>). The don't care bits mask out address bits in addition to the byte index LSBs. In hexadecimal integers, bit-granular don't-cares can be specified by inserting four-bit binary blocks enclosed in square braces in place of a hex digit.</p>
</li>
<li>
<p><code>&lt;address&gt;/&lt;size&gt;</code>: as before, but the number of ignored LSBs is explicitly set. This is generally a more convenient notation to use when assigning large blocks of memory to a field.</p>
</li>
<li>
<p><code>&lt;address&gt;|&lt;ignore&gt;</code>: specifies the byte address and ignored bits using two integers. Both integers can be specified in hexadecimal, binary, or decimal. A bit which is set in the <code>&lt;ignore&gt;</code> value is ignored by the address matcher.</p>
</li>
<li>
<p><code>&lt;address&gt;&amp;&lt;mask&gt;</code>: specifies the byte address and mask using two integers. Both integers can be specified in hexadecimal, binary, or decimal. A bit which is not set in the <code>&lt;ignore&gt;</code> value is ignored by the address matcher.</p>
</li>
</ul>
<p>This key is required.</p>
<a class="header" href="#conditions" id="conditions"><h2><code>conditions</code></h2></a>
<p>This key specifies additional address match conditions for the
logical register surrounding the fields described by this descriptor.
These are primarily intended to construct paged or indirect-access
register files, which may be useful when not enough address space is
allocated to the register file to fit all the registers, or when you
want to emulate legacy register files such as a 16550 UART.</p>
<p>The value for this key must match for all fields in the register, so
if you use this, it is recommended to use the <code>subfields</code> key to group
all fields that belong to the register together so you only have to
specify it once. In the future, <code>vhdmmio</code> may be extended to allow this
value to be field-specific.</p>
<p>This key must be set to a list of dictionaries, of which the structure is defined <a href="conditionconfig.html">here</a>.</p>
<p>This key is optional. Not specifying it is equivalent to specifying an empty list.</p>
<a class="header" href="#endianness-1" id="endianness-1"><h2><code>endianness</code></h2></a>
<p>This key specifies the endianness of the logical register
surrounding the fields described by this descriptor.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the endianness is taken from the global default (little), the register file default specified in the <code>features</code> key, or from other fields within the register that do specify a value.</p>
</li>
<li>
<p><code>little</code>: the logical register is little endian. That is, when multiple blocks are needed to describe the field(s), bit 0 of the register resides in the <em>first</em> block.</p>
</li>
<li>
<p><code>big</code>: the logical register is big endian. That is, when multiple blocks are needed to describe the field(s), bit 0 of the register resides in the <em>last</em> block.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#bitrange" id="bitrange"><h2><code>bitrange</code></h2></a>
<p>This key specifies the position of the first field described by this
descriptor within the surrounding logical register, and specifies its
vectorness.</p>
<p>Bit indices cannot go below 0, but they can be greater than or equal to
the bus width. In this case, the field &quot;spills over&quot; into the
subsequent block. For instance, for a 32-bit bus and little-endian
endianness, <code>8:47..8</code> maps to:</p>
<table><thead><tr><th> Address </th><th> 31..24 </th><th> 23..16 </th><th> 15..8  </th><th> 7..0   </th><th> Block name </th></tr></thead><tbody>
<tr><td> 0x08    </td><td> 23..16 </td><td> 15..8  </td><td>  7..0  </td><td>        </td><td> <code>...L</code>     </td></tr>
<tr><td> 0x0C    </td><td>        </td><td>        </td><td> 39..32 </td><td> 31..24 </td><td> <code>...H</code>     </td></tr>
</tbody></table>
<p>For big-endian it would be:</p>
<table><thead><tr><th> Address </th><th> 31..24 </th><th> 23..16 </th><th> 15..8  </th><th> 7..0   </th><th> Block name </th></tr></thead><tbody>
<tr><td> 0x08    </td><td>        </td><td>        </td><td> 39..32 </td><td> 31..24 </td><td> <code>...H</code>     </td></tr>
<tr><td> 0x0C    </td><td> 23..16 </td><td> 15..8  </td><td>  7..0  </td><td>        </td><td> <code>...L</code>     </td></tr>
</tbody></table>
<p>Following the usual nomenclature, 0x08 and 0x0C would be two different
registers, usually called <code>high</code> and <code>low</code> or some abbreviation
thereof. <code>vhdmmio</code> calls 0x08 and 0x0C physical registers (or, more
generally, blocks, which can have an arbitrary bitmask for the
address), which together form a single logical register.</p>
<p>Some output formats require unique names/mnemonics for blocks. Since
names can only be specified for logical registers as a whole, <code>vhdmmio</code>
needs to uniquify the identifiers on its own. It does this using the
following rules:</p>
<ul>
<li>logical registers with one block do not receive any name/mnemonic
suffix.</li>
<li>logical registers with two blocks receive <code>_high</code>/<code>H</code> and <code>_low</code>/<code>L</code>
suffixes for their name/mnemonic based on endianness.</li>
<li>logical registers with more than two blocks receive alphabetical
suffixes based on the block index (that is, regardless of
endianness). The name suffixes have the form <code>_&lt;lowercase&gt;</code>, while
the mnemonic suffixes are simply an uppercase letter.</li>
</ul>
<p>When the block address bitmask is nontrivial, the &quot;subsequent block&quot;
concept requires further elaboration. Consider for instance the address
<code>0b10--10--</code> in a 32-bit register file. You could argue that the next
block is <code>0b11--10--</code> or <code>0b10--11--</code>. <code>vhdmmio</code> opts for the latter.
Specifically, the final block addresses for each block and each of the
the four subaddresses would become:</p>
<table><thead><tr><th> Block </th><th> Mask          </th><th> Sub 0 </th><th> Sub 1 </th><th> Sub 2 </th><th> Sub 3 </th></tr></thead><tbody>
<tr><td> 0     </td><td> <code>0b10--10--</code> </td><td> 0x088 </td><td> 0x098 </td><td> 0x0A8 </td><td> 0x0B8 </td></tr>
<tr><td> 1     </td><td> <code>0b10--11--</code> </td><td> 0x08C </td><td> 0x09C </td><td> 0x0AC </td><td> 0x0BC </td></tr>
<tr><td> 2     </td><td> <code>0b11--00--</code> </td><td> 0x0C0 </td><td> 0x0D0 </td><td> 0x0E0 </td><td> 0x0F0 </td></tr>
<tr><td> 3     </td><td> <code>0b11--01--</code> </td><td> 0x0C4 </td><td> 0x0D4 </td><td> 0x0E4 </td><td> 0x0F4 </td></tr>
<tr><td> 4     </td><td> <code>0b11--10--</code> </td><td> 0x0C8 </td><td> 0x0D8 </td><td> 0x0E8 </td><td> 0x0F8 </td></tr>
<tr><td> 5     </td><td> <code>0b11--11--</code> </td><td> 0x0CC </td><td> 0x0DC </td><td> 0x0EC </td><td> 0x0FC </td></tr>
<tr><td> 6     </td><td> <code>0b100--00--</code> </td><td> 0x100 </td><td> 0x110 </td><td> 0x120 </td><td> 0x130 </td></tr>
<tr><td> ...   </td><td> ...           </td><td> ...   </td><td> ...   </td><td> ...   </td><td> ...   </td></tr>
</tbody></table>
<p>For field descriptors that describe an array of fields through the
<code>repeat</code> key, this bitrange specifies the position of the first field
in the array. Subsequent field positions are inferred based on
<code>field-stride</code> and <code>field-repeat</code>.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the field occupies the entire bus word, and is thus a vector of the same size as the bus.</p>
</li>
<li>
<p>an integer above or equal to 0: the field occupies a single bit with the specified index, and is thus a scalar.</p>
</li>
<li>
<p><code>&lt;high&gt;..&lt;low&gt;</code>: the field occupies the given inclusive bitrange, and is thus a vector of size <code>&lt;high&gt;</code> - <code>&lt;low&gt;</code> + 1.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#subaddress" id="subaddress"><h2><code>subaddress</code></h2></a>
<p>This key specifies how the subaddress for this field is generated.
This subaddress is used for memory-like fields, that need an address in
addition to read/write data.</p>
<p>If you leave this list empty or unspecified, the default is to build
the subaddress by concatenating the masked word address bits. This is
usually what you want. For instance, putting a 64-bit AXI field into a
32-bit register file yields an address like <code>0b----0--</code>. The block with
the first halfword then resides at that address, while the block with
the second halfword is at <code>0b----1--</code>. The four don't-cares to the left
of the block index bit form the subaddress, which the AXI field uses as
a 64-bit word address, leading to natural ordering.</p>
<p>For more advanced use cases, you can use this key to specify the
structure of the subaddress manually. It must be a list of so-called
components, each of which represents one or more subaddress bits taken
from some source. The source can be the incoming address, an internal
signal, an external input signal, or constant zero. The components are
then concatenated in LSB to MSB order, and optionally summed with
<code>subaddress_offset</code> to get the final subaddress.</p>
<p>This key must be set to a list of dictionaries, of which the structure is defined <a href="subaddressconfig.html">here</a>.</p>
<p>This key is optional. Not specifying it is equivalent to specifying an empty list.</p>
<a class="header" href="#subaddress-offset" id="subaddress-offset"><h2><code>subaddress-offset</code></h2></a>
<p>This key allows you to specify a constant offset for the subaddress.
The value is added to the result of the logic specified by the
<code>subaddress</code> key using a full adder before it is passed to the field.
This behavior can not always be emulated by entries in the <code>subaddress</code>
key alone due to the ripple carry logic.</p>
<p>Note that subaddresses are usually word-oriented. Fields can be
non-power-of-two-bytes wide, so byte addresses are often
meaningless.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>0</code> (default): no offset is applied.</p>
</li>
<li>
<p>a different integer: the given (word) offset is applied to the subaddress.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>0</code>) is used.</p>
<a class="header" href="#repeat" id="repeat"><h2><code>repeat</code></h2></a>
<p>This value specifies whether this field descriptor describes a
single field or an array of fields.</p>
<p>By default, the individual fields are placed in the same register,
as if they were concatenated in LSB to MSB order. This can be
customized using the <code>field-repeat</code>, <code>stride</code>, and <code>field-stride</code>
keys.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the descriptor describes a single field.</p>
</li>
<li>
<p>an integer above or equal to 1: the descriptor describes an array field of the given size.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#field-repeat" id="field-repeat"><h2><code>field-repeat</code></h2></a>
<p>This value specifies how many times this field is repeated within
each logical register before moving on to the next logical register.
For example, a field descriptor with a <code>repeat</code> of 7 and a
<code>field-repeat</code> of 3 may look like this:</p>
<table><thead><tr><th> Address  </th><th> Byte 3  </th><th> Byte 2  </th><th> Byte 1  </th><th> Byte 0  </th></tr></thead><tbody>
<tr><td> Base     </td><td>         </td><td> Field 2 </td><td> Field 1 </td><td> Field 0 </td></tr>
<tr><td> Base + 4 </td><td>         </td><td> Field 5 </td><td> Field 4 </td><td> Field 3 </td></tr>
<tr><td> Base + 8 </td><td>         </td><td>         </td><td>         </td><td> Field 6 </td></tr>
</tbody></table>
<p>With <code>field-repeat</code> set to <code>null</code> instead, they get grouped in the same
logical register, despite becoming wider than the bus (refer to the
docs for <code>bitrange</code> for more info):</p>
<table><thead><tr><th> Address  </th><th> Byte 3  </th><th> Byte 2  </th><th> Byte 1  </th><th> Byte 0  </th></tr></thead><tbody>
<tr><td> Base     </td><td> Field 3 </td><td> Field 2 </td><td> Field 1 </td><td> Field 0 </td></tr>
<tr><td> (cont.)  </td><td>         </td><td> Field 6 </td><td> Field 5 </td><td> Field 4 </td></tr>
</tbody></table>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): all fields are placed in the same logical register.</p>
</li>
<li>
<p><code>1</code>: each field gets its own logical register.</p>
</li>
<li>
<p>an integer above or equal to 2: the given amount of fields are placed in each logical register.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#stride" id="stride"><h2><code>stride</code></h2></a>
<p>This value specifies by how many blocks the address should be
advanced when moving to the next logical register due to
<code>field-repeat</code> &lt; <code>repeat</code>.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>1</code> (default): the address is incremented by one block. Note that this default is not correct when the logical register is wider than the bus.</p>
</li>
<li>
<p>a different integer: the address is incremented by this amount of blocks each time. Negative numbers can be used for big-endian indexation.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>1</code>) is used.</p>
<a class="header" href="#field-stride" id="field-stride"><h2><code>field-stride</code></h2></a>
<p>This value specifies by how many bits the bitrange low/high indices
should be advanced when moving to the next field within a single
logical register.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the bit index is incremented by the width of the field.</p>
</li>
<li>
<p>an integer: the bit index is incremented by this amount of bits each time. Negative values are allowed, as long as the base bitrange is high enough to prevent the final bit indices from falling below zero.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#metadata-keys" id="metadata-keys"><h2>Metadata keys</h2></a>
<p>This configuration structure is used to name and document the
field.</p>
<p>More information about this structure may be found <a href="metadataconfig.html">here</a>.</p>
<p>The following configuration keys are used to configure this structure.</p>
<a class="header" href="#mnemonic-1" id="mnemonic-1"><h3><code>mnemonic</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#mnemonic">here</a>.</p>
<a class="header" href="#name-1" id="name-1"><h3><code>name</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#name">here</a>.</p>
<a class="header" href="#brief-1" id="brief-1"><h3><code>brief</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#brief">here</a>.</p>
<a class="header" href="#doc-1" id="doc-1"><h3><code>doc</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#doc">here</a>.</p>
<a class="header" href="#register-" id="register-"><h2><code>register-*</code></h2></a>
<p>This optional configuration structure can be used to name and
document the logical register that this field resides in.</p>
<p>Registers can have the same or different metadata attached to them
based on the bus access mode (read/write). In the presence of multiple
metadata sources, the first one encountered in the following list is
used for the read metadata:</p>
<ul>
<li>the register metadata for the least significant readable field in
the logical register that carries it;</li>
<li>the register metadata for the least significant writable field in
the logical register that carries it;</li>
<li>generated from the field metadata for the least significant readable
field.</li>
<li>generated from the field metadata for the least significant writable
field.</li>
</ul>
<p>The generated metadata copies the mnemonic from the field, and uses the
field's name with <code>'_reg'</code> suffix for the name. The generated brief
just lists the fields in the register.</p>
<p>The priority list is the same for writes, but with points 1 and 2
flipped around (3 and 4 are NOT flipped). If the metadata for the two
access modes resolves to the same object, the register is documented
once as being R/W, even if some fields are read- or write-only and/or
overlap that way. Otherwise, it is documented twice, once as read-only
and once as write-only.</p>
<p>For example, in the 16550 UART, register 0/DLAB 0 is commonly referred
to as the receiver buffer register (<code>RBR</code>) in read mode and the
transmitter holding register (<code>THR</code>) in write mode, so you might want
to document them separately. On the other hand, you could also document
them once as a FIFO access register (<code>FAR</code>, for instance). This is
mostly a matter of taste.</p>
<p>More information about this structure may be found <a href="metadataconfig.html">here</a>.</p>
<p>The following configuration keys are used to configure this structure. This structure is optional, so it is legal to not specify any of them, except when this structure is required by context.</p>
<a class="header" href="#register-mnemonic" id="register-mnemonic"><h3><code>register-mnemonic</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#mnemonic">here</a>.</p>
<a class="header" href="#register-name" id="register-name"><h3><code>register-name</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#name">here</a>.</p>
<a class="header" href="#register-brief" id="register-brief"><h3><code>register-brief</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#brief">here</a>.</p>
<a class="header" href="#register-doc" id="register-doc"><h3><code>register-doc</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#doc">here</a>.</p>
<a class="header" href="#read-allow-" id="read-allow-"><h2><code>read-allow-*</code></h2></a>
<p>These keys describe which AXI4L <code>ar_prot</code> values are acceptable for
read transactions. By default, the <code>ar_prot</code> field is ignored, so all
masters can read from the field(s). These keys have no effect for
write-only fields.</p>
<p>More information about this structure may be found <a href="permissionconfig.html">here</a>.</p>
<p>The following configuration keys are used to configure this structure.</p>
<a class="header" href="#read-allow-user" id="read-allow-user"><h3><code>read-allow-user</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#user">here</a>.</p>
<a class="header" href="#read-allow-privileged" id="read-allow-privileged"><h3><code>read-allow-privileged</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#privileged">here</a>.</p>
<a class="header" href="#read-allow-secure" id="read-allow-secure"><h3><code>read-allow-secure</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#secure">here</a>.</p>
<a class="header" href="#read-allow-nonsecure" id="read-allow-nonsecure"><h3><code>read-allow-nonsecure</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#nonsecure">here</a>.</p>
<a class="header" href="#read-allow-data" id="read-allow-data"><h3><code>read-allow-data</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#data">here</a>.</p>
<a class="header" href="#read-allow-instruction" id="read-allow-instruction"><h3><code>read-allow-instruction</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#instruction">here</a>.</p>
<a class="header" href="#write-allow-" id="write-allow-"><h2><code>write-allow-*</code></h2></a>
<p>These keys describe which AXI4L <code>aw_prot</code> values are acceptable for
write transactions. By default, the <code>aw_prot</code> field is ignored, so all
masters can write to the field(s). These keys have no effect for
read-only fields.</p>
<p>More information about this structure may be found <a href="permissionconfig.html">here</a>.</p>
<p>The following configuration keys are used to configure this structure.</p>
<a class="header" href="#write-allow-user" id="write-allow-user"><h3><code>write-allow-user</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#user">here</a>.</p>
<a class="header" href="#write-allow-privileged" id="write-allow-privileged"><h3><code>write-allow-privileged</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#privileged">here</a>.</p>
<a class="header" href="#write-allow-secure" id="write-allow-secure"><h3><code>write-allow-secure</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#secure">here</a>.</p>
<a class="header" href="#write-allow-nonsecure" id="write-allow-nonsecure"><h3><code>write-allow-nonsecure</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#nonsecure">here</a>.</p>
<a class="header" href="#write-allow-data" id="write-allow-data"><h3><code>write-allow-data</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#data">here</a>.</p>
<a class="header" href="#write-allow-instruction" id="write-allow-instruction"><h3><code>write-allow-instruction</code></h3></a>
<p>This key is documented <a href="permissionconfig.html#instruction">here</a>.</p>
<a class="header" href="#interface-keys" id="interface-keys"><h2>Interface keys</h2></a>
<p>These keys specify how the VHDL entity interface is generated.</p>
<p>More information about this structure may be found <a href="interfaceconfig.html">here</a>.</p>
<p>The following configuration keys are used to configure this structure.</p>
<a class="header" href="#group-1" id="group-1"><h3><code>group</code></h3></a>
<p>This key is documented <a href="interfaceconfig.html#group">here</a>.</p>
<a class="header" href="#flatten-1" id="flatten-1"><h3><code>flatten</code></h3></a>
<p>This key is documented <a href="interfaceconfig.html#flatten">here</a>.</p>
<a class="header" href="#generic-group-1" id="generic-group-1"><h3><code>generic-group</code></h3></a>
<p>This key is documented <a href="interfaceconfig.html#generic-group">here</a>.</p>
<a class="header" href="#generic-flatten-1" id="generic-flatten-1"><h3><code>generic-flatten</code></h3></a>
<p>This key is documented <a href="interfaceconfig.html#generic-flatten">here</a>.</p>
<a class="header" href="#primitive-behavior" id="primitive-behavior"><h1><code>primitive</code> behavior</h1></a>
<p>This is the base class for regular field behavior. It can be used for
everything from simple status/control fields to stream interfaces and
performance counters. Most behaviors simply derive from this by overriding
some parameters and changing defaults for others.</p>
<p>A primitive field has up to two internal registers associated with it. One
contains data, and is thus as wide as the field is; the other is a single
bit representing whether the data register is valid. How these registers
are initialized and used (if at all) depends entirely on the
configuration.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#bus-read" id="bus-read"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): read access is disabled.</p>
</li>
<li>
<p><code>error</code>: reads always return a slave error.</p>
</li>
<li>
<p><code>enabled</code>: normal read access to field, ignoring valid bit.</p>
</li>
<li>
<p><code>valid-wait</code>: as above, but blocks until field is valid.</p>
</li>
<li>
<p><code>valid-only</code>: as above, but fails when field is not valid.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#after-bus-read" id="after-bus-read"><h2><code>after-bus-read</code></h2></a>
<p>Configures what happens after a bus read.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>nothing</code> (default): no extra operation after read.</p>
</li>
<li>
<p><code>invalidate</code>: field is invalidated and cleared after read.</p>
</li>
<li>
<p><code>clear</code>: field is cleared after read, valid untouched.</p>
</li>
<li>
<p><code>increment</code>: register is incremented after read, valid untouched.</p>
</li>
<li>
<p><code>decrement</code>: register is decremented after read, valid untouched.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>nothing</code>) is used.</p>
<a class="header" href="#bus-write" id="bus-write"><h2><code>bus-write</code></h2></a>
<p>Configures what happens when a bus write occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): write access is disabled.</p>
</li>
<li>
<p><code>error</code>: writes always return a slave error.</p>
</li>
<li>
<p><code>enabled</code>: normal write access to register. Masked bits are written 0.</p>
</li>
<li>
<p><code>invalid</code>: as above, but ignores the write when the register is valid.</p>
</li>
<li>
<p><code>invalid-wait</code>: as above, but blocks until register is invalid.</p>
</li>
<li>
<p><code>invalid-only</code>: as above, but fails when register is already valid.</p>
</li>
<li>
<p><code>masked</code>: write access respects strobe bits. Precludes after-bus-write.</p>
</li>
<li>
<p><code>accumulate</code>: write data is added to the register.</p>
</li>
<li>
<p><code>subtract</code>: write data is subtracted from the register.</p>
</li>
<li>
<p><code>bit-set</code>: bits that are written 1 are set in the register.</p>
</li>
<li>
<p><code>bit-clear</code>: bits that are written 1 are cleared in the register.</p>
</li>
<li>
<p><code>bit-toggle</code>: bits that are written 1 are toggled in the register.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#after-bus-write" id="after-bus-write"><h2><code>after-bus-write</code></h2></a>
<p>Configures what happens after a bus write.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>nothing</code> (default): no extra operation after write.</p>
</li>
<li>
<p><code>validate</code>: register is validated after write.</p>
</li>
<li>
<p><code>invalidate</code>: as above, but invalidated again one cycle later.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>nothing</code>) is used.</p>
<a class="header" href="#hw-read" id="hw-read"><h2><code>hw-read</code></h2></a>
<p>Configure the existence and behavior of the hardware read port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no read port is generated.</p>
</li>
<li>
<p><code>simple</code>: only the data output is generated.</p>
</li>
<li>
<p><code>enabled</code>: both a data and a valid output signal are generated.</p>
</li>
<li>
<p><code>handshake</code>: a stream-to-mmio ready signal is generated.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#hw-write" id="hw-write"><h2><code>hw-write</code></h2></a>
<p>Configure the existence and behavior of the hardware write port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no write port is generated.</p>
</li>
<li>
<p><code>status</code>: the register is constantly driven by a port and is always valid.</p>
</li>
<li>
<p><code>enabled</code>: a record consisting of a write enable flag and data is generated.</p>
</li>
<li>
<p><code>stream</code>: like enabled, but the write only occurs when the register is invalid. Furthermore, the <code>write_data</code> signal is renamed to <code>data</code>, and the <code>write_enable</code> signal is renamed to <code>valid</code>, in order to comply with AXI-stream naming conventions.</p>
</li>
<li>
<p><code>accumulate</code>: like enabled, but the data is accumulated instead of written.</p>
</li>
<li>
<p><code>subtract</code>: like enabled, but the data is subtracted instead of written.</p>
</li>
<li>
<p><code>set</code>: like enabled, but bits that are written 1 are set in the register.</p>
</li>
<li>
<p><code>reset</code>: like enabled, but bits that are written 1 are cleared in the register.</p>
</li>
<li>
<p><code>toggle</code>: like enabled, but bits that are written 1 are toggled in the register.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#after-hw-write" id="after-hw-write"><h2><code>after-hw-write</code></h2></a>
<p>Configures what happens after a hardware write.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>nothing</code> (default): no extra operation after write.</p>
</li>
<li>
<p><code>validate</code>: register is automatically validated after write.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>nothing</code>) is used.</p>
<a class="header" href="#reset" id="reset"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p><code>null</code>: the internal data register resets to 0, with the valid flag cleared.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-lock" id="ctrl-lock"><h2><code>ctrl-lock</code></h2></a>
<p>Controls the existence of the <code>ctrl_lock</code> control input signal. When
this signal is asserted, writes are ignored.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-validate" id="ctrl-validate"><h2><code>ctrl-validate</code></h2></a>
<p>Controls the existence of the <code>ctrl_validate</code> control input signal.
When this signal is asserted, the internal valid flag is set.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-invalidate" id="ctrl-invalidate"><h2><code>ctrl-invalidate</code></h2></a>
<p>Controls the existence of the <code>ctrl_invalidate</code> control input
signal. When this signal is asserted, the internal valid flag is
cleared. The data register is also set to 0.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-ready" id="ctrl-ready"><h2><code>ctrl-ready</code></h2></a>
<p>Controls the existence of the <code>ctrl_ready</code> control input signal.
This signal behaves like an AXI stream ready signal for MMIO to stream
fields.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-clear" id="ctrl-clear"><h2><code>ctrl-clear</code></h2></a>
<p>Controls the existence of the <code>ctrl_clear</code> control input
signal. When this signal is asserted, the internal data register is
cleared. The valid flag is not affected.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-reset" id="ctrl-reset"><h2><code>ctrl-reset</code></h2></a>
<p>Controls the existence of the <code>ctrl_reset</code> control input
signal. When this signal is asserted, the field is reset, as if the
register file <code>reset</code> input were asserted.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-increment" id="ctrl-increment"><h2><code>ctrl-increment</code></h2></a>
<p>Controls the existence of the <code>ctrl_increment</code> control input
signal. When this signal is asserted, the internal data register is
incremented.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-decrement" id="ctrl-decrement"><h2><code>ctrl-decrement</code></h2></a>
<p>Controls the existence of the <code>ctrl_decrement</code> control input
signal. When this signal is asserted, the internal data register is
decremented.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-bit-set" id="ctrl-bit-set"><h2><code>ctrl-bit-set</code></h2></a>
<p>Controls the existence of the <code>ctrl_bit_set</code> control input
signal. This signal is as wide as the field is. When a bit in this
input is high, the respective data bit is set.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-bit-clear" id="ctrl-bit-clear"><h2><code>ctrl-bit-clear</code></h2></a>
<p>Controls the existence of the <code>ctrl_bit_clear</code> control input
signal. This signal is as wide as the field is. When a bit in this
input is high, the respective data bit is cleared.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-bit-toggle" id="ctrl-bit-toggle"><h2><code>ctrl-bit-toggle</code></h2></a>
<p>Controls the existence of the <code>ctrl_bit_toggle</code> control input
signal. This signal is as wide as the field is. When a bit in this
input is high, the respective data bit is toggled.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#drive-internal" id="drive-internal"><h2><code>drive-internal</code></h2></a>
<p>Configures driving or strobing an internal signal with the internal
data register belonging to this field. The signal is strobed when
<code>after-bus-write</code> is set to <code>invalidate</code>, otherwise it is driven.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created and driven with the value in the internal data register for this field.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#full-internal" id="full-internal"><h2><code>full-internal</code></h2></a>
<p>Configures driving an internal signal high when the internal data
register is valid. This essentially serves as a holding register full
signal for stream interface fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and driven by the internal valid register of this field.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#empty-internal" id="empty-internal"><h2><code>empty-internal</code></h2></a>
<p>Configures driving an internal signal high when the internal data
register is invalid. This essentially serves as a holding register
empty signal for stream interface fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and driven by the one's complement of the internal valid register of this field.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#overflow-internal" id="overflow-internal"><h2><code>overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when the most significant bit
of the internal register flips from high to low during an increment or
accumulate operation. This essentially serves as an overflow signal for
counter fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when an increment or accumulate operation causes the MSB of the data register to be cleared.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#underflow-internal" id="underflow-internal"><h2><code>underflow-internal</code></h2></a>
<p>Configures strobing an internal signal when the most significant bit
of the internal register flips from low to high during a decrement or
subtract operation. This essentially serves as an underflow signal for
counter fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a decrement or subtract operation causes the MSB of the data register to be set.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#bit-overflow-internal" id="bit-overflow-internal"><h2><code>bit-overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when a bit-set operation to
a bit that was already set occurs. This essentially serves as an
overflow signal for flag fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bit-set operation occurs to an already-set bit.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#bit-underflow-internal" id="bit-underflow-internal"><h2><code>bit-underflow-internal</code></h2></a>
<p>Configures strobing an internal signal when a bit-clear operation to
a bit that was already cleared occurs. This essentially serves as an
underflow signal for flag fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bit-clear operation occurs to an already-cleared bit.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#overrun-internal" id="overrun-internal"><h2><code>overrun-internal</code></h2></a>
<p>Configures strobing an internal signal when a bus write occurs while
the stored value was already valid. This is equivalent to an overflow
condition for MMIO to stream fields. It is intended to be used for
overflow interrupts.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bus write occurs while the internal valid signal is set.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#underrun-internal" id="underrun-internal"><h2><code>underrun-internal</code></h2></a>
<p>Configures strobing an internal signal when a bus read occurs while
the stored value is invalid. This is equivalent to an underflow
condition for stream to MMIO fields. It is intended to be used for
underflow interrupts.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bus read occurs while the internal valid signal is cleared.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#monitor-internal" id="monitor-internal"><h2><code>monitor-internal</code></h2></a>
<p>Configures monitoring an internal signal with this field.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: the field monitors the internal signal with the given name. <code>monitor-mode</code> determines how the signal is used.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#monitor-mode" id="monitor-mode"><h2><code>monitor-mode</code></h2></a>
<p>Configures how <code>monitor-internal</code> works. If <code>monitor-internal</code> is
not specified, this key is no-op.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>status</code> (default): the internal data register is constantly assigned to the vector-sized internal signal named by <code>monitor-internal</code>.</p>
</li>
<li>
<p><code>bit-set</code>: the internal data register is constantly or'd with the vector-sized internal signal named by <code>monitor-internal</code>.</p>
</li>
<li>
<p><code>increment</code>: the internal data register is incremented whenever the respective bit in the repeat-sized internal signal named by <code>monitor-internal</code> is asserted.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>status</code>) is used.</p>
<a class="header" href="#constant-behavior" id="constant-behavior"><h1><code>constant</code> behavior</h1></a>
<p>Fields with <code>constant</code> behavior always return the value specified
through the <code>value</code> option when read. They cannot be written.</p>
<p>This structure supports the following configuration key.</p>
<a class="header" href="#value" id="value"><h2><code>value</code></h2></a>
<p>Configures the value using an integer or boolean.</p>
<p>This key is required.</p>
<a class="header" href="#config-behavior" id="config-behavior"><h1><code>config</code> behavior</h1></a>
<p>Fields with <code>config</code> behavior always return the value specified by a
VHDL generic. They cannot be written.</p>
<p>This structure does not support any configuration keys.</p>
<a class="header" href="#status-behavior" id="status-behavior"><h1><code>status</code> behavior</h1></a>
<p>Fields with <code>status</code> behavior always return the current state of an
input port. They cannot be written.</p>
<p>This structure does not support any configuration keys.</p>
<a class="header" href="#internal-status-behavior" id="internal-status-behavior"><h1><code>internal-status</code> behavior</h1></a>
<p>Fields with <code>internal-status</code> behavior always return the current state
if an internal signal.</p>
<p>This structure supports the following configuration key.</p>
<a class="header" href="#internal" id="internal"><h2><code>internal</code></h2></a>
<p>Configures the internal signal that is to be monitored. The value
must be a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>.</p>
<p>This key is required.</p>
<a class="header" href="#latching-behavior" id="latching-behavior"><h1><code>latching</code> behavior</h1></a>
<p>The <code>latching</code> behavior is a lot like <code>status</code>, but more advanced. It is
used when status information is not always available, but only updated
sporadically through a write enable. This means that there is an &quot;invalid&quot;
state of some kind, used before the first status value is received. By
default fields with this behavior will just read as 0 in this state, but
this behavior can be overridden with the options below. For instance, the
field can be configured to block the read access until the status is valid.
It's also possible to enable a control signal that invalidates the field on
demand, or to invalidate on read.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#bus-read-1" id="bus-read-1"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>enabled</code> (default): normal read access to field, ignoring valid bit.</p>
</li>
<li>
<p><code>valid-wait</code>: as above, but blocks until field is valid.</p>
</li>
<li>
<p><code>valid-only</code>: as above, but fails when field is not valid.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#after-bus-read-1" id="after-bus-read-1"><h2><code>after-bus-read</code></h2></a>
<p>Configures what happens after a bus read.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>nothing</code> (default): no extra operation after read.</p>
</li>
<li>
<p><code>invalidate</code>: field is invalidated and cleared after read.</p>
</li>
<li>
<p><code>clear</code>: field is cleared after read, valid untouched.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>nothing</code>) is used.</p>
<a class="header" href="#after-hw-write-1" id="after-hw-write-1"><h2><code>after-hw-write</code></h2></a>
<p>Configures what happens after a hardware write.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>nothing</code> (default): no extra operation after write.</p>
</li>
<li>
<p><code>validate</code>: register is automatically validated after write.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>nothing</code>) is used.</p>
<a class="header" href="#reset-1" id="reset-1"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code>: the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p><code>null</code> (default): the internal data register resets to 0, with the valid flag cleared.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#ctrl-validate-1" id="ctrl-validate-1"><h2><code>ctrl-validate</code></h2></a>
<p>Controls the existence of the <code>ctrl_validate</code> control input signal.
When this signal is asserted, the internal valid flag is set.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-invalidate-1" id="ctrl-invalidate-1"><h2><code>ctrl-invalidate</code></h2></a>
<p>Controls the existence of the <code>ctrl_invalidate</code> control input
signal. When this signal is asserted, the internal valid flag is
cleared. The data register is also set to 0.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-clear-1" id="ctrl-clear-1"><h2><code>ctrl-clear</code></h2></a>
<p>Controls the existence of the <code>ctrl_clear</code> control input
signal. When this signal is asserted, the internal data register is
cleared. The valid flag is not affected.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-reset-1" id="ctrl-reset-1"><h2><code>ctrl-reset</code></h2></a>
<p>Controls the existence of the <code>ctrl_reset</code> control input
signal. When this signal is asserted, the field is reset, as if the
register file <code>reset</code> input were asserted.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-increment-1" id="ctrl-increment-1"><h2><code>ctrl-increment</code></h2></a>
<p>Controls the existence of the <code>ctrl_increment</code> control input
signal. When this signal is asserted, the internal data register is
incremented.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-decrement-1" id="ctrl-decrement-1"><h2><code>ctrl-decrement</code></h2></a>
<p>Controls the existence of the <code>ctrl_decrement</code> control input
signal. When this signal is asserted, the internal data register is
decremented.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-bit-set-1" id="ctrl-bit-set-1"><h2><code>ctrl-bit-set</code></h2></a>
<p>Controls the existence of the <code>ctrl_bit_set</code> control input
signal. This signal is as wide as the field is. When a bit in this
input is high, the respective data bit is set.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-bit-clear-1" id="ctrl-bit-clear-1"><h2><code>ctrl-bit-clear</code></h2></a>
<p>Controls the existence of the <code>ctrl_bit_clear</code> control input
signal. This signal is as wide as the field is. When a bit in this
input is high, the respective data bit is cleared.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-bit-toggle-1" id="ctrl-bit-toggle-1"><h2><code>ctrl-bit-toggle</code></h2></a>
<p>Controls the existence of the <code>ctrl_bit_toggle</code> control input
signal. This signal is as wide as the field is. When a bit in this
input is high, the respective data bit is toggled.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#control" id="control"><h1><code>Control</code></h1></a>
<p>Fields with <code>control</code> behavior are used to push runtime configuration
values from software to hardware. They are normally read-write on the MMIO
bus and respect the AXI4L byte strobe bits so they can be easily (though
not necessarily atomically) updated partially, but read access can be
disabled and write access can be simplified if this is desirable.</p>
<p>The hardware interface by default consists of just an <code>std_logic</code> or
<code>std_logic_vector</code> with the current value of the field, but you can also
enable a valid bit by setting <code>hw-read</code> to <code>enabled</code> if you so desire.
You'll also need to set <code>bus-write</code> to <code>enabled</code> and <code>after-bus-write</code> to
<code>validate</code> to make that work as you would expect: the value will be marked
invalid from reset to when it's first written. You can also make the field
one-time-programmable by selecting <code>invalid</code> or <code>invalid-only</code> for
<code>bus-write</code> instead of <code>enabled</code>.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#bus-read-2" id="bus-read-2"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>enabled</code> (default): normal read access to field, ignoring valid bit.</p>
</li>
<li>
<p><code>error</code>: reads always return a slave error.</p>
</li>
<li>
<p><code>disabled</code>: read access is disabled.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#bus-write-1" id="bus-write-1"><h2><code>bus-write</code></h2></a>
<p>Configures what happens when a bus write occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>masked</code> (default): write access respects strobe bits. Precludes after-bus-write.</p>
</li>
<li>
<p><code>enabled</code>: normal write access to register. Masked bits are written 0.</p>
</li>
<li>
<p><code>invalid</code>: as above, but ignores the write when the register is valid.</p>
</li>
<li>
<p><code>invalid-only</code>: as above, but fails when register is already valid.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>masked</code>) is used.</p>
<a class="header" href="#after-bus-write-1" id="after-bus-write-1"><h2><code>after-bus-write</code></h2></a>
<p>Configures what happens after a bus write.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>nothing</code> (default): no extra operation after write.</p>
</li>
<li>
<p><code>validate</code>: register is validated after write.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>nothing</code>) is used.</p>
<a class="header" href="#hw-read-1" id="hw-read-1"><h2><code>hw-read</code></h2></a>
<p>Configure the existence and behavior of the hardware read port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>simple</code> (default): only the data output is generated.</p>
</li>
<li>
<p><code>enabled</code>: both a data and a valid output signal are generated.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>simple</code>) is used.</p>
<a class="header" href="#reset-2" id="reset-2"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code>: the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p><code>null</code> (default): the internal data register resets to 0, with the valid flag cleared.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#ctrl-lock-1" id="ctrl-lock-1"><h2><code>ctrl-lock</code></h2></a>
<p>Controls the existence of the <code>ctrl_lock</code> control input signal. When
this signal is asserted, writes are ignored.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-invalidate-2" id="ctrl-invalidate-2"><h2><code>ctrl-invalidate</code></h2></a>
<p>Controls the existence of the <code>ctrl_invalidate</code> control input
signal. When this signal is asserted, the internal valid flag is
cleared. The data register is also set to 0.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-reset-2" id="ctrl-reset-2"><h2><code>ctrl-reset</code></h2></a>
<p>Controls the existence of the <code>ctrl_reset</code> control input
signal. When this signal is asserted, the field is reset, as if the
register file <code>reset</code> input were asserted.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#internal-control-behavior" id="internal-control-behavior"><h1><code>internal-control</code> behavior</h1></a>
<p>This field behaves like a control register that constrols an internal
signal by default. That is, the MMIO bus interface is read/write, and the
contents of the internal register drives an internal signal. The name of
the internal signal must be set using <code>drive-internal</code>.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#bus-read-3" id="bus-read-3"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>enabled</code> (default): normal read access to field, ignoring valid bit.</p>
</li>
<li>
<p><code>error</code>: reads always return a slave error.</p>
</li>
<li>
<p><code>disabled</code>: read access is disabled.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#bus-write-2" id="bus-write-2"><h2><code>bus-write</code></h2></a>
<p>Configures what happens when a bus write occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>masked</code> (default): write access respects strobe bits. Precludes after-bus-write.</p>
</li>
<li>
<p><code>enabled</code>: normal write access to register. Masked bits are written 0.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>masked</code>) is used.</p>
<a class="header" href="#reset-3" id="reset-3"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#internal-1" id="internal-1"><h2><code>internal</code></h2></a>
<p>Configures the internal signal that is to be driven. The value
must be a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>.</p>
<p>This key is required.</p>
<a class="header" href="#flag-behavior" id="flag-behavior"><h1><code>flag</code> behavior</h1></a>
<p>Fields with `flag' behavior behave like most edge/event-sensitive
interrupt flags in commercial peripherals work: occurance of the event
sets the flag bit, and writing a one to the bit through MMIO clears it
again.</p>
<p>Usually many of these flags are combined into a single register. Canonical
usage by software is then to read the register to determine which events
have occurred, write the read value back to the register, and then handle
the events. If a new event occurs between the read and write, its flag
will not be cleared, because a zero will be written to it by the write
action. This event will then be handled the next time the software reads
the flag register.</p>
<p>It normally isn't possible to detect how many events have occurred for a
single flag, just that there was at least one occurrance since the last
read of the flag. If this information is necessary, the <code>counter</code> behavior
can be used instead. If only the knowledge that an overflow occurred is
needed, <code>bit-overflow-internal</code> can be used to drive an <code>internal-flag</code>
field and/or an internal interrupt.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#hw-read-2" id="hw-read-2"><h2><code>hw-read</code></h2></a>
<p>Configure the existence and behavior of the hardware read port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no read port is generated.</p>
</li>
<li>
<p><code>simple</code>: only the data output is generated.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#reset-4" id="reset-4"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#bit-overflow-internal-1" id="bit-overflow-internal-1"><h2><code>bit-overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when a bit-set operation to
a bit that was already set occurs. This essentially serves as an
overflow signal for flag fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bit-set operation occurs to an already-set bit.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#bit-underflow-internal-1" id="bit-underflow-internal-1"><h2><code>bit-underflow-internal</code></h2></a>
<p>Configures strobing an internal signal when a bit-clear operation to
a bit that was already cleared occurs. This essentially serves as an
underflow signal for flag fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bit-clear operation occurs to an already-cleared bit.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#volatile-flag-behavior" id="volatile-flag-behavior"><h1><code>volatile-flag</code> behavior</h1></a>
<p>This behavior is similar to <code>flag</code>, but the flags are immediately
cleared when the field is read. The field is therefore read-only, allowing
write-only registers to reside at the same address. The access procedure
is also slightly faster, because no write action is required. However, the
required read-volatility makes it incompatible with processors/caches that
prefetch values; any infrastructure that may perform spurious reads may
inadvertantly clear the flags.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#hw-read-3" id="hw-read-3"><h2><code>hw-read</code></h2></a>
<p>Configure the existence and behavior of the hardware read port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no read port is generated.</p>
</li>
<li>
<p><code>simple</code>: only the data output is generated.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#reset-5" id="reset-5"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#bit-overflow-internal-2" id="bit-overflow-internal-2"><h2><code>bit-overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when a bit-set operation to
a bit that was already set occurs. This essentially serves as an
overflow signal for flag fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bit-set operation occurs to an already-set bit.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#internal-flag-behavior" id="internal-flag-behavior"><h1><code>internal-flag</code> behavior</h1></a>
<p><code>internal-flag</code> fields behave like <code>flag</code> fields, but instead of the
flags being set by an external signal, it is set by an internal signal.
This may for instance be used in conjunction with the overrun output of an
MMIO to stream field.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#hw-read-4" id="hw-read-4"><h2><code>hw-read</code></h2></a>
<p>Configure the existence and behavior of the hardware read port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no read port is generated.</p>
</li>
<li>
<p><code>simple</code>: only the data output is generated.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#reset-6" id="reset-6"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#bit-overflow-internal-3" id="bit-overflow-internal-3"><h2><code>bit-overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when a bit-set operation to
a bit that was already set occurs. This essentially serves as an
overflow signal for flag fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bit-set operation occurs to an already-set bit.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#bit-underflow-internal-2" id="bit-underflow-internal-2"><h2><code>bit-underflow-internal</code></h2></a>
<p>Configures strobing an internal signal when a bit-clear operation to
a bit that was already cleared occurs. This essentially serves as an
underflow signal for flag fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bit-clear operation occurs to an already-cleared bit.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#internal-2" id="internal-2"><h2><code>internal</code></h2></a>
<p>Configures the internal signal that is to be monitored. The value
must be a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>.</p>
<p>This key is required.</p>
<a class="header" href="#volatile-internal-flag-behavior" id="volatile-internal-flag-behavior"><h1><code>volatile-internal-flag</code> behavior</h1></a>
<p><code>volatile-internal-flag</code> fields behave like <code>volatile-flag</code> fields, but
instead of the flags being set by an external signal, it is set by an
internal signal. This may for instance be used in conjunction with the
overrun output of an MMIO to stream field.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#hw-read-5" id="hw-read-5"><h2><code>hw-read</code></h2></a>
<p>Configure the existence and behavior of the hardware read port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no read port is generated.</p>
</li>
<li>
<p><code>simple</code>: only the data output is generated.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#reset-7" id="reset-7"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#bit-overflow-internal-4" id="bit-overflow-internal-4"><h2><code>bit-overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when a bit-set operation to
a bit that was already set occurs. This essentially serves as an
overflow signal for flag fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bit-set operation occurs to an already-set bit.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#internal-3" id="internal-3"><h2><code>internal</code></h2></a>
<p>Configures the internal signal that is to be monitored. The value
must be a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>.</p>
<p>This key is required.</p>
<a class="header" href="#strobe-behavior" id="strobe-behavior"><h1><code>strobe</code> behavior</h1></a>
<p>This behavior may be used to signal a request to hardware, for hardware
that can always handle the request immediately. When a 1 is written to a
bit in this register, the respective output bit is strobed high for one
cycle. Zero writes are ignored.</p>
<p>This structure does not support any configuration keys.</p>
<a class="header" href="#internal-strobe-behavior" id="internal-strobe-behavior"><h1><code>internal-strobe</code> behavior</h1></a>
<p>This behavior may be used to signal a request to another <code>vhdmmio</code>
entity, such as a counter field. When a 1 is written to a bit in this
register, the respective bit in the internal signal is strobed high for one
cycle. Zero writes are ignored.</p>
<p>This structure supports the following configuration key.</p>
<a class="header" href="#internal-4" id="internal-4"><h2><code>internal</code></h2></a>
<p>Configures the internal signal that is to be driven. The value
must be a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>.</p>
<p>This key is required.</p>
<a class="header" href="#request-behavior" id="request-behavior"><h1><code>request</code> behavior</h1></a>
<p>This behavior can be seen as both the inverse of a <code>flag</code> and as an
extension of <code>strobe</code>: the bits in the field are set by software writing
a one to them, and cleared when acknowledged by hardware. They can be used
for requests that cannot be handled immediately. By default, software can
use an MMIO read to determine whether a command has been acknowledged yet,
but this can be disabled to make the field write-only.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#bus-read-4" id="bus-read-4"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>enabled</code> (default): normal read access to field, ignoring valid bit.</p>
</li>
<li>
<p><code>error</code>: reads always return a slave error.</p>
</li>
<li>
<p><code>disabled</code>: read access is disabled.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#reset-8" id="reset-8"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-clear-2" id="ctrl-clear-2"><h2><code>ctrl-clear</code></h2></a>
<p>Controls the existence of the <code>ctrl_clear</code> control input
signal. When this signal is asserted, the internal data register is
cleared. The valid flag is not affected.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-reset-3" id="ctrl-reset-3"><h2><code>ctrl-reset</code></h2></a>
<p>Controls the existence of the <code>ctrl_reset</code> control input
signal. When this signal is asserted, the field is reset, as if the
register file <code>reset</code> input were asserted.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-bit-clear-2" id="ctrl-bit-clear-2"><h2><code>ctrl-bit-clear</code></h2></a>
<p>Controls the existence of the <code>ctrl_bit_clear</code> control input
signal. This signal is as wide as the field is. When a bit in this
input is high, the respective data bit is cleared.</p>
<p>The value must be a boolean (default <code>yes</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>yes</code>) is used.</p>
<a class="header" href="#bit-overflow-internal-5" id="bit-overflow-internal-5"><h2><code>bit-overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when a bit-set operation to
a bit that was already set occurs. This essentially serves as an
overflow signal for flag fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bit-set operation occurs to an already-set bit.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#bit-underflow-internal-3" id="bit-underflow-internal-3"><h2><code>bit-underflow-internal</code></h2></a>
<p>Configures strobing an internal signal when a bit-clear operation to
a bit that was already cleared occurs. This essentially serves as an
underflow signal for flag fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bit-clear operation occurs to an already-cleared bit.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#multi-request-behavior" id="multi-request-behavior"><h1><code>multi-request</code> behavior</h1></a>
<p><code>multi-request</code> fields accumulate anything written to them, and by
default allow hardware to decrement them. This may be used to request
a certain number of things with a single, atomic MMIO write.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#bus-read-5" id="bus-read-5"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>enabled</code> (default): normal read access to field, ignoring valid bit.</p>
</li>
<li>
<p><code>error</code>: reads always return a slave error.</p>
</li>
<li>
<p><code>disabled</code>: read access is disabled.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#hw-write-1" id="hw-write-1"><h2><code>hw-write</code></h2></a>
<p>Configure the existence and behavior of the hardware write port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no write port is generated.</p>
</li>
<li>
<p><code>subtract</code>: like enabled, but the data is subtracted instead of written.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#reset-9" id="reset-9"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-clear-3" id="ctrl-clear-3"><h2><code>ctrl-clear</code></h2></a>
<p>Controls the existence of the <code>ctrl_clear</code> control input
signal. When this signal is asserted, the internal data register is
cleared. The valid flag is not affected.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-reset-4" id="ctrl-reset-4"><h2><code>ctrl-reset</code></h2></a>
<p>Controls the existence of the <code>ctrl_reset</code> control input
signal. When this signal is asserted, the field is reset, as if the
register file <code>reset</code> input were asserted.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-decrement-2" id="ctrl-decrement-2"><h2><code>ctrl-decrement</code></h2></a>
<p>Controls the existence of the <code>ctrl_decrement</code> control input
signal. When this signal is asserted, the internal data register is
decremented.</p>
<p>The value must be a boolean (default <code>yes</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>yes</code>) is used.</p>
<a class="header" href="#overflow-internal-1" id="overflow-internal-1"><h2><code>overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when the most significant bit
of the internal register flips from high to low during an increment or
accumulate operation. This essentially serves as an overflow signal for
counter fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when an increment or accumulate operation causes the MSB of the data register to be cleared.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#underflow-internal-1" id="underflow-internal-1"><h2><code>underflow-internal</code></h2></a>
<p>Configures strobing an internal signal when the most significant bit
of the internal register flips from low to high during a decrement or
subtract operation. This essentially serves as an underflow signal for
counter fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a decrement or subtract operation causes the MSB of the data register to be set.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#counter-behavior" id="counter-behavior"><h1><code>counter</code> behavior</h1></a>
<p>Similar to <code>flag</code> fields, <code>counter</code>s are used to signal events from
hardware to software. However, counters allow multiple events occurring
between consecutive software read cycles to be registered by counting
instead of bit-setting. Like <code>flag</code>, software should use fields of this
type by reading the value and then writing the read value to it in order
to avoid missing events; the write operation subtracts the written value
from the internal register.</p>
<p>When a counter overflows, it simply wraps back to zero. Similarly, if a
counter is decremented below zero, it wraps to its maximum value.
Optionally, <code>overflow-internal</code> and <code>underflow-internal</code> can be used to
detect this condition, in conjuntion with an <code>internal-flag</code> field and/or
an internal interrupt.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#hw-read-6" id="hw-read-6"><h2><code>hw-read</code></h2></a>
<p>Configure the existence and behavior of the hardware read port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no read port is generated.</p>
</li>
<li>
<p><code>simple</code>: only the data output is generated.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#hw-write-2" id="hw-write-2"><h2><code>hw-write</code></h2></a>
<p>Configure the existence and behavior of the hardware write port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no write port is generated.</p>
</li>
<li>
<p><code>enabled</code>: a record consisting of a write enable flag and data is generated.</p>
</li>
<li>
<p><code>accumulate</code>: like enabled, but the data is accumulated instead of written.</p>
</li>
<li>
<p><code>subtract</code>: like enabled, but the data is subtracted instead of written.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#reset-10" id="reset-10"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-clear-4" id="ctrl-clear-4"><h2><code>ctrl-clear</code></h2></a>
<p>Controls the existence of the <code>ctrl_clear</code> control input
signal. When this signal is asserted, the internal data register is
cleared. The valid flag is not affected.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-reset-5" id="ctrl-reset-5"><h2><code>ctrl-reset</code></h2></a>
<p>Controls the existence of the <code>ctrl_reset</code> control input
signal. When this signal is asserted, the field is reset, as if the
register file <code>reset</code> input were asserted.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-increment-2" id="ctrl-increment-2"><h2><code>ctrl-increment</code></h2></a>
<p>Controls the existence of the <code>ctrl_increment</code> control input
signal. When this signal is asserted, the internal data register is
incremented.</p>
<p>The value must be a boolean (default <code>yes</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>yes</code>) is used.</p>
<a class="header" href="#ctrl-decrement-3" id="ctrl-decrement-3"><h2><code>ctrl-decrement</code></h2></a>
<p>Controls the existence of the <code>ctrl_decrement</code> control input
signal. When this signal is asserted, the internal data register is
decremented.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#overflow-internal-2" id="overflow-internal-2"><h2><code>overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when the most significant bit
of the internal register flips from high to low during an increment or
accumulate operation. This essentially serves as an overflow signal for
counter fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when an increment or accumulate operation causes the MSB of the data register to be cleared.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#underflow-internal-2" id="underflow-internal-2"><h2><code>underflow-internal</code></h2></a>
<p>Configures strobing an internal signal when the most significant bit
of the internal register flips from low to high during a decrement or
subtract operation. This essentially serves as an underflow signal for
counter fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a decrement or subtract operation causes the MSB of the data register to be set.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#volatile-counter-behavior" id="volatile-counter-behavior"><h1><code>volatile-counter</code> behavior</h1></a>
<p>This behavior is similar to <code>counter</code>, but the counter value is
immediately cleared when the field is read. The field is therefore
read-only, allowing write-only registers to reside at the same address
The access procedure is also slightly faster, because no write action is
required. However, the required read-volatility makes it incompatible
with processors/caches that prefetch values; any infrastructure that
may perform spurious reads may inadvertantly clear the counter.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#hw-read-7" id="hw-read-7"><h2><code>hw-read</code></h2></a>
<p>Configure the existence and behavior of the hardware read port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no read port is generated.</p>
</li>
<li>
<p><code>simple</code>: only the data output is generated.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#hw-write-3" id="hw-write-3"><h2><code>hw-write</code></h2></a>
<p>Configure the existence and behavior of the hardware write port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no write port is generated.</p>
</li>
<li>
<p><code>enabled</code>: a record consisting of a write enable flag and data is generated.</p>
</li>
<li>
<p><code>accumulate</code>: like enabled, but the data is accumulated instead of written.</p>
</li>
<li>
<p><code>subtract</code>: like enabled, but the data is subtracted instead of written.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#reset-11" id="reset-11"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-clear-5" id="ctrl-clear-5"><h2><code>ctrl-clear</code></h2></a>
<p>Controls the existence of the <code>ctrl_clear</code> control input
signal. When this signal is asserted, the internal data register is
cleared. The valid flag is not affected.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-reset-6" id="ctrl-reset-6"><h2><code>ctrl-reset</code></h2></a>
<p>Controls the existence of the <code>ctrl_reset</code> control input
signal. When this signal is asserted, the field is reset, as if the
register file <code>reset</code> input were asserted.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-increment-3" id="ctrl-increment-3"><h2><code>ctrl-increment</code></h2></a>
<p>Controls the existence of the <code>ctrl_increment</code> control input
signal. When this signal is asserted, the internal data register is
incremented.</p>
<p>The value must be a boolean (default <code>yes</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>yes</code>) is used.</p>
<a class="header" href="#ctrl-decrement-4" id="ctrl-decrement-4"><h2><code>ctrl-decrement</code></h2></a>
<p>Controls the existence of the <code>ctrl_decrement</code> control input
signal. When this signal is asserted, the internal data register is
decremented.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#overflow-internal-3" id="overflow-internal-3"><h2><code>overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when the most significant bit
of the internal register flips from high to low during an increment or
accumulate operation. This essentially serves as an overflow signal for
counter fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when an increment or accumulate operation causes the MSB of the data register to be cleared.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#internal-counter-behavior" id="internal-counter-behavior"><h1><code>internal-counter</code> behavior</h1></a>
<p>This field behaves like <code>counter</code>, but instead of the counter being
incremented by an external signal, it is incremented by an internal
signal.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#hw-read-8" id="hw-read-8"><h2><code>hw-read</code></h2></a>
<p>Configure the existence and behavior of the hardware read port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no read port is generated.</p>
</li>
<li>
<p><code>simple</code>: only the data output is generated.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#hw-write-4" id="hw-write-4"><h2><code>hw-write</code></h2></a>
<p>Configure the existence and behavior of the hardware write port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no write port is generated.</p>
</li>
<li>
<p><code>enabled</code>: a record consisting of a write enable flag and data is generated.</p>
</li>
<li>
<p><code>accumulate</code>: like enabled, but the data is accumulated instead of written.</p>
</li>
<li>
<p><code>subtract</code>: like enabled, but the data is subtracted instead of written.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#reset-12" id="reset-12"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-clear-6" id="ctrl-clear-6"><h2><code>ctrl-clear</code></h2></a>
<p>Controls the existence of the <code>ctrl_clear</code> control input
signal. When this signal is asserted, the internal data register is
cleared. The valid flag is not affected.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-reset-7" id="ctrl-reset-7"><h2><code>ctrl-reset</code></h2></a>
<p>Controls the existence of the <code>ctrl_reset</code> control input
signal. When this signal is asserted, the field is reset, as if the
register file <code>reset</code> input were asserted.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-increment-4" id="ctrl-increment-4"><h2><code>ctrl-increment</code></h2></a>
<p>Controls the existence of the <code>ctrl_increment</code> control input
signal. When this signal is asserted, the internal data register is
incremented.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-decrement-5" id="ctrl-decrement-5"><h2><code>ctrl-decrement</code></h2></a>
<p>Controls the existence of the <code>ctrl_decrement</code> control input
signal. When this signal is asserted, the internal data register is
decremented.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#overflow-internal-4" id="overflow-internal-4"><h2><code>overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when the most significant bit
of the internal register flips from high to low during an increment or
accumulate operation. This essentially serves as an overflow signal for
counter fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when an increment or accumulate operation causes the MSB of the data register to be cleared.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#underflow-internal-3" id="underflow-internal-3"><h2><code>underflow-internal</code></h2></a>
<p>Configures strobing an internal signal when the most significant bit
of the internal register flips from low to high during a decrement or
subtract operation. This essentially serves as an underflow signal for
counter fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a decrement or subtract operation causes the MSB of the data register to be set.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#internal-5" id="internal-5"><h2><code>internal</code></h2></a>
<p>Configures the internal signal that is to be monitored. The value
must be a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>.</p>
<p>This key is required.</p>
<a class="header" href="#volatile-internal-counter-behavior" id="volatile-internal-counter-behavior"><h1><code>volatile-internal-counter</code> behavior</h1></a>
<p>This field behaves like <code>volatile-counter</code>, but instead of the counter
being incremented by an external signal, it is incremented by an internal
signal.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#hw-read-9" id="hw-read-9"><h2><code>hw-read</code></h2></a>
<p>Configure the existence and behavior of the hardware read port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no read port is generated.</p>
</li>
<li>
<p><code>simple</code>: only the data output is generated.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#hw-write-5" id="hw-write-5"><h2><code>hw-write</code></h2></a>
<p>Configure the existence and behavior of the hardware write port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): no write port is generated.</p>
</li>
<li>
<p><code>enabled</code>: a record consisting of a write enable flag and data is generated.</p>
</li>
<li>
<p><code>accumulate</code>: like enabled, but the data is accumulated instead of written.</p>
</li>
<li>
<p><code>subtract</code>: like enabled, but the data is subtracted instead of written.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#reset-13" id="reset-13"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-clear-7" id="ctrl-clear-7"><h2><code>ctrl-clear</code></h2></a>
<p>Controls the existence of the <code>ctrl_clear</code> control input
signal. When this signal is asserted, the internal data register is
cleared. The valid flag is not affected.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-reset-8" id="ctrl-reset-8"><h2><code>ctrl-reset</code></h2></a>
<p>Controls the existence of the <code>ctrl_reset</code> control input
signal. When this signal is asserted, the field is reset, as if the
register file <code>reset</code> input were asserted.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-increment-5" id="ctrl-increment-5"><h2><code>ctrl-increment</code></h2></a>
<p>Controls the existence of the <code>ctrl_increment</code> control input
signal. When this signal is asserted, the internal data register is
incremented.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#ctrl-decrement-6" id="ctrl-decrement-6"><h2><code>ctrl-decrement</code></h2></a>
<p>Controls the existence of the <code>ctrl_decrement</code> control input
signal. When this signal is asserted, the internal data register is
decremented.</p>
<p>The value must be a boolean (default <code>no</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#overflow-internal-5" id="overflow-internal-5"><h2><code>overflow-internal</code></h2></a>
<p>Configures strobing an internal signal when the most significant bit
of the internal register flips from high to low during an increment or
accumulate operation. This essentially serves as an overflow signal for
counter fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when an increment or accumulate operation causes the MSB of the data register to be cleared.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#internal-6" id="internal-6"><h2><code>internal</code></h2></a>
<p>Configures the internal signal that is to be monitored. The value
must be a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>.</p>
<p>This key is required.</p>
<a class="header" href="#stream-to-mmio-behavior" id="stream-to-mmio-behavior"><h1><code>stream-to-mmio</code> behavior</h1></a>
<p>Fields with <code>stream-to-mmio</code> behavior interface with an incoming AXI4
stream. When the incoming AXI4 stream is valid and the internal register
for the field is not, the stream is handshaked and the data is put in the
register. The MMIO bus can then read from the field to fetch the data,
automatically invalidating the internal register to let the cycle repeat.
The field cannot be written by the bus.</p>
<p>By default, the only way for software to know whether data is waiting in
the internal holding register is to read and compare with zero, which is
always what's returned for an empty holding register. This is of course
not ideal at best. <code>vhdmmio</code> provides several options for doing this
better, which require a bit more work:</p>
<ul>
<li>Set <code>bus-read</code> to <code>valid-wait</code>. In this case, reads will always return
valid data because they are blocked until data is available. This is
the simplest method, but reading from a stream that isn't going to send
anything will deadlock the whole bus.</li>
<li>Set <code>bus-read</code> to <code>valid-only</code>. In this case, a read from an empty
holding register yields a slave error. This is very simple from
<code>vhdmmio</code>'s standpoint, but requires the bus master to actually support
AXI4L error conditions in a convenient way.</li>
<li>Drive an internal signal with the status of the holding register
(<code>full-internal</code> or <code>empty-internal</code>), and monitor it with a status
field (<code>internal-status</code> behavior) and/or an internal interrupt.</li>
<li>Strobe an internal signal when an invalid bus read occurs using
<code>underrun-internal</code> and check whether an underrun occurred after the
fact using a status field (<code>internal-flag</code> behavior) and/or an internal
interrupt.</li>
</ul>
<p>Finally, <code>vhdmmio</code> allows you to set the reset value of the internal
register to a valid value. This effectively imitates a stream transfer,
which may be used to start some loop based on sending stream transfers
back and forth between systems.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#bus-read-6" id="bus-read-6"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>enabled</code> (default): reads from an empty holding register return 0.</p>
</li>
<li>
<p><code>valid-only</code>: reads from an empty holding register return a slave error.</p>
</li>
<li>
<p><code>valid-wait</code>: reads from an empty holding register are blocked until data is received from the stream.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#reset-14" id="reset-14"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the internal data register resets to 0, with the valid flag cleared.</p>
</li>
<li>
<p><code>no</code>: the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#full-internal-1" id="full-internal-1"><h2><code>full-internal</code></h2></a>
<p>Configures driving an internal signal high when the internal data
register is valid. This essentially serves as a holding register full
signal for stream interface fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and driven by the internal valid register of this field.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#empty-internal-1" id="empty-internal-1"><h2><code>empty-internal</code></h2></a>
<p>Configures driving an internal signal high when the internal data
register is invalid. This essentially serves as a holding register
empty signal for stream interface fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and driven by the one's complement of the internal valid register of this field.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#underrun-internal-1" id="underrun-internal-1"><h2><code>underrun-internal</code></h2></a>
<p>Configures strobing an internal signal when a bus read occurs while
the stored value is invalid. This is equivalent to an underflow
condition for stream to MMIO fields. It is intended to be used for
underflow interrupts.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bus read occurs while the internal valid signal is cleared.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#mmio-to-stream-behavior" id="mmio-to-stream-behavior"><h1><code>mmio-to-stream</code> behavior</h1></a>
<p>Fields with <code>mmio-to-stream</code> behavior interface with an outgoing AXI4
stream. When the field is written, the written data is placed in the
field's internal data register and the stream is validated. A completed
handshake invalidates the internal data register, allowing the MMIO bus
master to write the next value. The field cannot be read by the bus.</p>
<p>By default, there is no way for software to know whether the holding
register is ready for the next datum. This is not a problem if flow
control is handled by some other means. However, <code>vhdmmio</code> also provides
several methods to achieve proper flow control:</p>
<ul>
<li>Set <code>bus-write</code> to <code>invalid-wait</code>. In this case, writes are blocked
until the holding register is ready. This is the simplest flow control
method, but writing to a stream that isn't going to acknowledge anything
will deadlock the whole bus.</li>
<li>Set <code>bus-write</code> to <code>invalid-only</code>. In this case, writing to a full
holding register yields a slave error. This is very simple from
<code>vhdmmio</code>'s standpoint, but requires the bus master to actually support
AXI4L error conditions in a convenient way.</li>
<li>Drive an internal signal with the status of the holding register
(<code>full-internal</code> or <code>empty-internal</code>), and monitor it with a status
field (<code>internal-status</code> behavior) and/or an internal interrupt.</li>
<li>Strobe an internal signal when an invalid bus write occurs using
<code>overrun-internal</code> and check whether an overrun occurred after the
fact using a status field (<code>internal-flag</code> behavior) and/or an internal
interrupt.</li>
</ul>
<p>Finally, <code>vhdmmio</code> allows you to set the reset value of the internal
register to a valid value. This effectively imitates a stream transfer,
which may be used to start some loop based on sending stream transfers
back and forth between systems.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#bus-write-3" id="bus-write-3"><h2><code>bus-write</code></h2></a>
<p>Configures what happens when a bus write occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>invalid</code> (default): writes to a full holding register are silently ignored.</p>
</li>
<li>
<p><code>enabled</code>: writes to a full holding register override the register. NOTE: this is not AXI4-stream compliant behavior, since <code>data</code> must remain stable between validation and the completed handshake.</p>
</li>
<li>
<p><code>invalid-wait</code>: writes to a full holding register are blocked until the register is popped by the stream.</p>
</li>
<li>
<p><code>invalid-only</code>: writes to a full holding register return a slave error.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>invalid</code>) is used.</p>
<a class="header" href="#reset-15" id="reset-15"><h2><code>reset</code></h2></a>
<p>Configures the reset value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the internal data register resets to 0, with the valid flag cleared.</p>
</li>
<li>
<p><code>no</code>: the internal data register resets to 0, with the valid flag set.</p>
</li>
<li>
<p><code>yes</code>: the internal data register resets to 1, with the valid flag set.</p>
</li>
<li>
<p>an integer: the internal data register resets to the given value, with the valid flag set.</p>
</li>
<li>
<p><code>generic</code>: the reset value is controlled through a VHDL generic.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#full-internal-2" id="full-internal-2"><h2><code>full-internal</code></h2></a>
<p>Configures driving an internal signal high when the internal data
register is valid. This essentially serves as a holding register full
signal for stream interface fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and driven by the internal valid register of this field.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#empty-internal-2" id="empty-internal-2"><h2><code>empty-internal</code></h2></a>
<p>Configures driving an internal signal high when the internal data
register is invalid. This essentially serves as a holding register
empty signal for stream interface fields.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and driven by the one's complement of the internal valid register of this field.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#overrun-internal-1" id="overrun-internal-1"><h2><code>overrun-internal</code></h2></a>
<p>Configures strobing an internal signal when a bus write occurs while
the stored value was already valid. This is equivalent to an overflow
condition for MMIO to stream fields. It is intended to be used for
overflow interrupts.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and strobed when a bus write occurs while the internal valid signal is set.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#axi-behavior" id="axi-behavior"><h1><code>axi</code> behavior</h1></a>
<p>Fields with <code>axi</code> behavior map the bus accesses supported by them to a
different AXI4L bus.</p>
<p>The width of the outgoing AXI4L bus is set to the width of the field, which
must therefore be 32 or 64 bits. The <em>word</em> address for the outgoing bus is
taken from the <a href="fieldconfig.html#subaddress">subaddress</a>; the 2 or 3 LSBs of
the address (depending on the bus width) are always zero. For example, a
field with address <code>0x0---</code> in a 32-bit system has a 10-bit subaddress,
therefore allowing access to 4kiB of address space on the child AXI4L port.</p>
<p>Note that going from a 64-bit bus to a 32-bit bus always &quot;stretches&quot; the
address space of the 32-bit bus, since only half the bus width can be
utilized. While it would technically be possible to avoid this by just
doing two transfers on the slave bus for each AXI field access, this adds
a bunch of complexity, ambiguity, and may prevent read-volatile fields on
the child bus from being accessed without side effects, so this feature was
not implemented. Going from a 32-bit bus to a 64-bit bus on the other hand
is perfectly fine, since this just makes the logical register for the AXI
field wider than the bus, following <code>vhdmmio</code>'s normal rules. Just make
sure that bit 2 of the field's address is zero.</p>
<p><code>axi</code> fields support multiple outstanding requests. The amount of
outstanding requests supported is controlled centrally in the register file
features structure.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#mode" id="mode"><h2><code>mode</code></h2></a>
<p>This key configures the supported bus access modes.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>read-write</code> (default): both read and write accesses are supported.</p>
</li>
<li>
<p><code>read-only</code>: only read accesses are supported.</p>
</li>
<li>
<p><code>write-only</code>: only write accesses are supported.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>read-write</code>) is used.</p>
<a class="header" href="#interrupt-internal" id="interrupt-internal"><h2><code>interrupt-internal</code></h2></a>
<p>This key configures driving an internal signal high when the
<code>vhdmmio</code>-specific interrupt signal associated with the outgoing AXI4L
stream is asserted. This internal signal can then be tied to an
internal interrupt to propagate the flag.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the feature is disabled.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: an internal signal with the given name is created (if necessary) and driven by the incoming interrupt signal.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#bus-flatten-1" id="bus-flatten-1"><h2><code>bus-flatten</code></h2></a>
<p>This key specifies whether records or flattened signals are desired
for the bus interface. Note that <code>flatten</code> (defined
<a href="interfaceconfig.html#flatten">here</a>) should also be set to <code>yes</code> to make
this work.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the bus is not flattened; the records from <code>vhdmmio_pkg.vhd</code> are used.</p>
</li>
<li>
<p><code>yes</code>: the bus is flattened; the standard AXI4-lite signal names are used.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#interrupt-behavior" id="interrupt-behavior"><h1><code>interrupt</code> behavior</h1></a>
<p>This is the base class for the behavior of interrupt fields, i.e. fields
that operate on <code>vhdmmio</code>'s built-in interrupt system. They are associated
with an interrupt defined in the <code>interrupts</code> key of the register file
description. The arrayness of the interrupt must match the
repetition/arrayness of the field descriptor, and the individual fields
must be scalar.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#interrupt" id="interrupt"><h2><code>interrupt</code></h2></a>
<p>The name of the interrupt or interrupt array that this field is
associated with.</p>
<p>This key is required.</p>
<a class="header" href="#mode-1" id="mode-1"><h2><code>mode</code></h2></a>
<p>The role that this field assumes for the associated interrupt.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>raw</code> (default): this field monitors the raw incoming interrupt request.</p>
</li>
<li>
<p><code>enable</code>: this field monitors and/or controls the interrupt enable flag.</p>
</li>
<li>
<p><code>flag</code>: this field monitors and/or controls the interrupt status flag.</p>
</li>
<li>
<p><code>unmask</code>: this field monitors and/or controls the interrupt unmask flag.</p>
</li>
<li>
<p><code>masked</code>: this field monitors the masked interrupt status flag.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>raw</code>) is used.</p>
<a class="header" href="#bus-read-7" id="bus-read-7"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): read access is disabled.</p>
</li>
<li>
<p><code>enabled</code>: read access is enabled.</p>
</li>
<li>
<p><code>clear</code>: read access is enabled, and reading clears the associated flag.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#bus-write-4" id="bus-write-4"><h2><code>bus-write</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code> (default): write access is disabled.</p>
</li>
<li>
<p><code>enabled</code>: write access is enabled.</p>
</li>
<li>
<p><code>clear</code>: write access is enabled, and writing a one clears the associated flag.</p>
</li>
<li>
<p><code>set</code>: write access is enabled, and writing a one sets the associated flag.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>disabled</code>) is used.</p>
<a class="header" href="#interrupt-flag-behavior" id="interrupt-flag-behavior"><h1><code>interrupt-flag</code> behavior</h1></a>
<p>This field behavior works much like a regular <code>flag</code> field, but operates
on the interrupt pending flag of the associated interrupt instead of a
field-specific register. The read value of the field is one if and only if
the interrupt is pending, regardless of mask. Writing a one to the field
clears the flag. If only one of these operations is needed, the other can
be disabled.</p>
<p>If the write mode of this field is enabled, the associated interrupt
implicitly becomes strobe-sensitive.</p>
<p>The arrayness of the interrupt must match the repetition/arrayness of the
field descriptor. The individual fields must be scalar.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#interrupt-1" id="interrupt-1"><h2><code>interrupt</code></h2></a>
<p>The name of the interrupt or interrupt array that this field is
associated with.</p>
<p>This key is required.</p>
<a class="header" href="#bus-read-8" id="bus-read-8"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>enabled</code> (default): read access is enabled.</p>
</li>
<li>
<p><code>disabled</code>: read access is disabled.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#bus-write-5" id="bus-write-5"><h2><code>bus-write</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>clear</code> (default): write access is enabled, and writing a one clears the associated flag.</p>
</li>
<li>
<p><code>disabled</code>: write access is disabled.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>clear</code>) is used.</p>
<a class="header" href="#volatile-interrupt-flag-behavior" id="volatile-interrupt-flag-behavior"><h1><code>volatile-interrupt-flag</code> behavior</h1></a>
<p>This field behavior works much like a regular <code>volatile-flag</code> field, but
operates on the interrupt pending flag of the associated interrupt instead
of a field-specific register. The read value of the field is one if and
only if the interrupt is pending, and the act of reading the field clears
the interrupt pending status. Since the interrupt flag can be cleared, the
associated interrupt implicitly becomes strobe-sensitive.</p>
<p>The arrayness of the interrupt must match the repetition/arrayness of the
field descriptor. The individual fields must be scalar.</p>
<p>This structure supports the following configuration key.</p>
<a class="header" href="#interrupt-2" id="interrupt-2"><h2><code>interrupt</code></h2></a>
<p>The name of the interrupt or interrupt array that this field is
associated with.</p>
<p>This key is required.</p>
<a class="header" href="#interrupt-pend-behavior" id="interrupt-pend-behavior"><h1><code>interrupt-pend</code> behavior</h1></a>
<p>This field behavior allows software to set pend interrupts manually by
writing a one, regardless of the enable flag or the incoming interrupt
request. Since the interrupt flag can be set, the associated interrupt
implicitly becomes strobe-sensitive, and needs a way to clear the flag as
well. This can be done by reading this field when <code>bus-read</code> is set to
<code>clear</code>, or through a (<code>volatile-</code>)<code>interrupt-flag</code> field.</p>
<p>The arrayness of the interrupt must match the repetition/arrayness of the
field descriptor. The individual fields must be scalar.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#interrupt-3" id="interrupt-3"><h2><code>interrupt</code></h2></a>
<p>The name of the interrupt or interrupt array that this field is
associated with.</p>
<p>This key is required.</p>
<a class="header" href="#bus-read-9" id="bus-read-9"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code>: read access is disabled.</p>
</li>
<li>
<p><code>enabled</code> (default): read access is enabled.</p>
</li>
<li>
<p><code>clear</code>: read access is enabled, and reading clears the associated flag.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#interrupt-enable-behavior" id="interrupt-enable-behavior"><h1><code>interrupt-enable</code> behavior</h1></a>
<p>This field behavior allows software to access the enable register
for the associated interrupt. Incoming interrupt requests only affect the
interrupt flag register when the enable register is set. If there is no
way to enable an interrupt, it resets to the enabled state; otherwise it
resets to disabled.</p>
<p>The arrayness of the interrupt must match the repetition/arrayness of the
field descriptor. The individual fields must be scalar.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#interrupt-4" id="interrupt-4"><h2><code>interrupt</code></h2></a>
<p>The name of the interrupt or interrupt array that this field is
associated with.</p>
<p>This key is required.</p>
<a class="header" href="#bus-read-10" id="bus-read-10"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>enabled</code> (default): read access is enabled.</p>
</li>
<li>
<p><code>disabled</code>: read access is disabled.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#bus-write-6" id="bus-write-6"><h2><code>bus-write</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code>: write access is disabled.</p>
</li>
<li>
<p><code>enabled</code> (default): write access is enabled.</p>
</li>
<li>
<p><code>clear</code>: write access is enabled, and writing a one clears the associated flag.</p>
</li>
<li>
<p><code>set</code>: write access is enabled, and writing a one sets the associated flag.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#interrupt-unmask-behavior" id="interrupt-unmask-behavior"><h1><code>interrupt-unmask</code> behavior</h1></a>
<p>This field behavior allows software to access the unmask register
for the associated interrupt. A pending interrupt only asserts the outgoing
interrupt flag signal when it is unmasked. If there is no way to unmask an
interrupt, it resets to the unmasked state; otherwise it resets to masked.</p>
<p>The arrayness of the interrupt must match the repetition/arrayness of the
field descriptor. The individual fields must be scalar.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#interrupt-5" id="interrupt-5"><h2><code>interrupt</code></h2></a>
<p>The name of the interrupt or interrupt array that this field is
associated with.</p>
<p>This key is required.</p>
<a class="header" href="#bus-read-11" id="bus-read-11"><h2><code>bus-read</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>enabled</code> (default): read access is enabled.</p>
</li>
<li>
<p><code>disabled</code>: read access is disabled.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#bus-write-7" id="bus-write-7"><h2><code>bus-write</code></h2></a>
<p>Configures what happens when a bus read occurs.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>disabled</code>: write access is disabled.</p>
</li>
<li>
<p><code>enabled</code> (default): write access is enabled.</p>
</li>
<li>
<p><code>clear</code>: write access is enabled, and writing a one clears the associated flag.</p>
</li>
<li>
<p><code>set</code>: write access is enabled, and writing a one sets the associated flag.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>enabled</code>) is used.</p>
<a class="header" href="#interrupt-status-behavior" id="interrupt-status-behavior"><h1><code>interrupt-status</code> behavior</h1></a>
<p>This read-only field behavior reflects the state of the interrupt flag
register masked by the interrupt mask register. It is one if and only if
the interrupt is pending and unmasked.</p>
<p>The arrayness of the interrupt must match the repetition/arrayness of the
field descriptor. The individual fields must be scalar.</p>
<p>This structure supports the following configuration key.</p>
<a class="header" href="#interrupt-6" id="interrupt-6"><h2><code>interrupt</code></h2></a>
<p>The name of the interrupt or interrupt array that this field is
associated with.</p>
<p>This key is required.</p>
<a class="header" href="#interrupt-raw-behavior" id="interrupt-raw-behavior"><h1><code>interrupt-raw</code> behavior</h1></a>
<p>This read-only field behavior reflects the state of the raw incoming
interrupt signal, regardless of whether the interrupt is enabled or whether
the flag is set.</p>
<p>The arrayness of the interrupt must match the repetition/arrayness of the
field descriptor. The individual fields must be scalar.</p>
<p>This structure supports the following configuration key.</p>
<a class="header" href="#interrupt-7" id="interrupt-7"><h2><code>interrupt</code></h2></a>
<p>The name of the interrupt or interrupt array that this field is
associated with.</p>
<p>This key is required.</p>
<a class="header" href="#custom-behavior" id="custom-behavior"><h1><code>custom</code> behavior</h1></a>
<p>Custom fields allow you to describe the behavior of the field using
VHDL snippits. This is very powerful, but not for the faint-hearted. Also,
with great power comes great responsibility: you can easily break
<code>vhdmmio</code>'s generated entities by writing incorrect code. Furthermore,
<code>vhdmmio</code>'s internal template engine can execute arbitrary Python code, so
building a register file from an untrusted source that contains custom
fields is a big security risk. Therefore, <code>vhdmmio</code> requires you to specify
<code>--trusted</code> on the command line to be able to use these fields.</p>
<p><code>vhdmmio</code> implements custom fields in a tightly integrated way; it doesn't
just copypaste your code directly into the generated output file. Instead,
it lets you write code snippits for various actions, that get executed
within the generated VHDL process at the appropriate times. This is exactly
how the predefined field behaviors are programmed within <code>vhdmmio</code> - custom
fields basically just allow direct access to this API. The big advantage of
this is that you still don't need to worry about things like the AXI4L
interface or interoperability with any other fields in the logical register
or register file, but it does mean that you need to specify quite some
metadata to <code>vhdmmio</code> to make things work, and that you need a good
understanding of how <code>vhdmmio</code>'s generated VHDL code works.</p>
<a class="header" href="#specifying-field-behavior" id="specifying-field-behavior"><h1>Specifying field behavior</h1></a>
<p>The behavior of a field needs to be specified in two different ways. The
first is obvious: (templates for) the VHDL code that gets inserted into
the generated entity. The second consists of a more abstract description of
the field's capabilities and characteristics, which <code>vhdmmio</code> uses to
generate the glue logic between the fields and the AXI4L bus, the header
files for accessing the registers, and in some cases the documentation.</p>
<p><code>vhdmmio</code> allows you to specify the following VHDL code blocks. Note that
<code>vhdmmio</code>'s generated entity is entirely synchronous and uses variables to
maintain state, so the order of the blocks is important; the blocks are
listed in the order in which they are executed.</p>
<ul>
<li><code>pre-access</code>: this code block is executed every clock cycle <em>before</em> the
AXI4L bus access is handled.</li>
<li><code>read</code>: this code block is executed when the bus is trying to read the
field, and the bus interface logic is ready for the field's response.</li>
<li><code>read-lookahead</code>: like <code>read</code>, but the bus interface logic is <em>not</em> yet
ready for the response.</li>
<li><code>read-request</code>: this code block is executed when a read request for the
field is available, regardless of whether the bus interface logic is
ready for the response.</li>
<li><code>read-response</code>: this code block is executed when one of the above
blocks deferred a read, and the bus interface logic is ready for the
response.</li>
<li><code>write</code>, <code>write-lookahead</code>, <code>write-request</code>, and <code>write-response</code>: the
write analogues for the above.</li>
<li><code>post-access</code>: this code block is executed every clock cycle <em>after</em> the
AXI4L bus access is handled.</li>
</ul>
<p>For more information about each block, refer to the documentation below.</p>
<p><code>vhdmmio</code> needs the following metadata in addition to the code blocks:</p>
<ul>
<li>whether the <code>read</code>/<code>read-request</code>/<code>write</code>/<code>write-request</code> code blocks
can block a bus access (that is, delay the bus response);</li>
<li>whether reads/writes are volatile (that is, the result of accessing the
field once differs from accessing it twice);</li>
<li>how the field can be accessed without affecting its state, if this is
possible at all (used when a different field within a single logical
register is to be accessed).</li>
</ul>
<p>This metadata is also used to determine whether two fields can coexist
within the same register. The rules are:</p>
<ul>
<li>blocking fields cannot be combined with other blocking fields;</li>
<li>blocking fields cannot be combined with volatile fields;</li>
<li>fields that support multiple outstanding requests cannot be combined
with any other field.</li>
</ul>
<a class="header" href="#template-syntax" id="template-syntax"><h1>Template syntax</h1></a>
<p><code>vhdmmio</code> uses a custom template engine to preprocess VHDL code. The code
blocks specified in for custom fields pass through this template engine as
well.</p>
<p>The template engine is controlled using three characters that are normally
not used in VHDL: <code>|</code>, <code>$</code>, and <code>@</code>. Each corresponds to a different phase
of the template logic.</p>
<a class="header" href="#indentation-stripping-phase-" id="indentation-stripping-phase-"><h2>Indentation stripping phase (<code>|</code>)</h2></a>
<p>In this phase, all whitespace at the start of a line followed by a <code>|</code> is
stripped. This allows you to indent your template however you want, without
this indentation appearing in the generated code block. If you need to
start a line with an <code>|</code> for some reason, simply prefix a second <code>|</code>; the
substitution is only done once per line.</p>
<a class="header" href="#substitution-phase-" id="substitution-phase-"><h2>Substitution phase (<code>$</code>)</h2></a>
<p>This is the most important phase, dealing with substitutions and
conditionals, similar to the functionality of the C preprocessor.</p>
<p>The template engine supports both inline and single-line directives.
Single-line directives start with a <code>$</code>, followed by any amount of
whitespace, followed by a command, followed by some arguments depending on
the command. There should not be any whitespace before the <code>$</code> sign; to
indent such commands you need to use the <code>|</code> syntax described above.
Conversely, inline directives both start and end with a <code>$</code> and can be
anywhere on a line. To insert a <code>$</code> in the output, use <code>$$</code>.</p>
<p>The following single-line directives are available:</p>
<ul>
<li><code>$if &lt;python-expression&gt;</code>: opens a conditional block based on an
expression evaluated by Python.</li>
<li><code>$else</code>: opens the <code>else</code> block for a previous <code>$if</code>.</li>
<li><code>$endif</code>: terminates an <code>$if</code> or <code>$else</code> block.</li>
<li><code>$block &lt;name&gt;</code>: defines/adds code to a named block. This is like
<code>#define</code> in the C preprocessor, but multiline.</li>
<li><code>$end_block</code>: terminates a block definition.</li>
<li><code>$&lt;name&gt;</code>: inserts a previously defined block. If there are no spaces
between the <code>$</code> and the name, no indentation is added; otherwise one
space plus the spacing between the <code>$</code> and the name is added for each
line.</li>
</ul>
<p>Inline directives are always evaluated directly by Python. The result of
the Python expression is cast to a string and inserted in place of the
directive.</p>
<p>The custom field logic makes some variables available within these
Python expressions. These are:</p>
<ul>
<li><code>i</code>: the field index within the field descriptor, or <code>None</code> if the
field descriptor describes only one field (that is, <code>repeat</code> is not
specified).</li>
<li><code>s</code>: structure containing the VHDL identifiers for each signal/variable
specified through the <code>interfaces</code> configuration key.</li>
</ul>
<p>Additional variables may be available depending on the block.</p>
<a class="header" href="#comment-and-wrapping-phase-" id="comment-and-wrapping-phase-"><h2>Comment and wrapping phase (<code>@</code>)</h2></a>
<p>This phase deals with generating aestetically pleasing, properly
line-wrapped code regardless of the current indentation depth, which is
impossible (or at least hard) to know when the template is written. The
following constructs are available:</p>
<ul>
<li>Lines that start with <code>@</code> are treated as comments. Subsequent comment
lines are treated as markdown, and are rewrapped as such to get to
column 80.</li>
<li>Lines that start with <code>@@</code> are also treated as comments, but are not
rewrapped.</li>
<li><code>@@@</code> at the start of a line maps to a single <code>@</code> in the output.</li>
<li>Inline <code>@</code> are replaced with either a space or a newline followed by
appropriate indentation, depending on line wrapping.</li>
<li>Inline <code>@@</code> maps to a single <code>@</code> in the output.</li>
</ul>
<a class="header" href="#configuration-keys-1" id="configuration-keys-1"><h2>Configuration keys</h2></a>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#interfaces" id="interfaces"><h2><code>interfaces</code></h2></a>
<p>This key specifies the interfaces and state variables that this
field uses.</p>
<p>This key must be set to a list of dictionaries, of which the structure is defined <a href="custominterfaceconfig.html">here</a>.</p>
<p>This key is optional. Not specifying it is equivalent to specifying an empty list.</p>
<a class="header" href="#pre-access" id="pre-access"><h2><code>pre-access</code></h2></a>
<p>This key specifies the VHDL template for the code block that is
executed each cycle <em>before</em> the bus is accessed. This is usually used
for initializing non-state variables and for connecting input signals
to the internal state.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): no pre-access code block is needed.</p>
</li>
<li>
<p>a string: insert the given pre-access code block.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#read" id="read"><h2><code>read</code></h2></a>
<p>This key specifies the VHDL template for the code block that is
executed when the bus is attempting to read the field while also ready
for the response.</p>
<p>The template must perform one of the following actions to respond to
the bus.</p>
<ul>
<li>Set the <code>$ack$</code> boolean variable to <code>true</code>, and the <code>$data$</code>
variable to the read result. <code>$data$</code> is appropriately sliced to
represent the shape of the field; that is, it is sliced to an
<code>std_logic</code> for scalar fields and to an appropriately sized
<code>std_logic_vector</code> for vector fields.</li>
<li>Set the <code>$nack$</code> boolean variable to <code>true</code> to respond with a
slave error.</li>
<li>Set the <code>$block$</code> boolean variable to <code>true</code> to stall. In this
case, the block will be executed again the next cycle. The
<code>read-can-block</code> key must be set in order to use this variable.</li>
<li>Set the <code>$defer$</code> boolean variable to <code>true</code> to defer. In this
case, the request logic will accept the bus request and send
subsequent requests to <code>read-lookahead</code> blocks, while the
response logic will start calling the <code>read-response</code> block to get
the response. Such a <code>read-response</code> block must be specified in
order to use this variable.</li>
<li>Nothing: the bus behaves as if the field does not exist. If there
are no other fields in the addressed register, a decode error is
returned.</li>
</ul>
<p>In addition to the field's interfaces, the template can use the
following variables:</p>
<ul>
<li><code>$prot$</code>: the <code>prot</code> field associated with the request as a
3-bit <code>std_logic_vector</code>.</li>
<li><code>$addr$</code>: the incoming bus address for the request as a 32-bit
<code>std_logic_vector</code>.</li>
<li><code>$sub$</code>: the subaddress for the for the request as an
<code>std_logic_vector</code> slice, of which the width depends on the
field's subaddress configuration.</li>
</ul>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): no read code block is needed.</p>
</li>
<li>
<p>a string: insert the given read code block.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#read-lookahead" id="read-lookahead"><h2><code>read-lookahead</code></h2></a>
<p>This key specifies the VHDL template for the code block that is
executed when the bus is attempting to read the field, but the
response logic is not yet ready for the response. This can be used to
initiate long transactions a few cycles earlier, or can be used in
conjunction with multiple outstanding request support.</p>
<p>The template must perform one of the following actions to respond to
the bus.</p>
<ul>
<li>Set the <code>$defer$</code> boolean variable to <code>true</code> to defer. In this
case, the request logic will accept the bus request and send
subsequent requests to <code>read-lookahead</code> blocks, while the
response logic will start calling the <code>read-response</code> block to get
the response. Such a <code>read-response</code> block must be specified in
order to use this variable.</li>
<li>Nothing: the bus interface logic will continue to call this block
in subsequent cycles until the response logic is ready, at which
point the regular <code>read</code> block is executed instead.</li>
</ul>
<p>In addition to the field's interfaces, the template can use the
following variables:</p>
<ul>
<li><code>$prot$</code>: the <code>prot</code> field associated with the request as a
3-bit <code>std_logic_vector</code>.</li>
<li><code>$addr$</code>: the incoming bus address for the request as a 32-bit
<code>std_logic_vector</code>.</li>
<li><code>$sub$</code>: the subaddress for the for the request as an
<code>std_logic_vector</code> slice, of which the width depends on the
field's subaddress configuration.</li>
</ul>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): no read lookahead code block is needed.</p>
</li>
<li>
<p>a string: insert the given read lookahead code block.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#read-request" id="read-request"><h2><code>read-request</code></h2></a>
<p>This key specifies the VHDL template for the code block that is
executed when the bus is attempting to read the field, regardless of
whether the bus is ready for the response. It is up to the code block
itself to check this where needed, using the <code>$resp_ready$</code> boolean
variable. Depending on this boolean, the block must respond to the
access as described in the documentation for the <code>read</code> and
<code>read-lookahead</code> blocks.</p>
<p>While uncommon, both <code>read</code>/<code>read-lookahead</code> and <code>read-request</code> may be
specified at the same time. In this case, <code>read</code>/<code>read-lookahead</code> is
executed before <code>read-request</code>.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): no read request code block is needed.</p>
</li>
<li>
<p>a string: insert the given read request code block.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#read-response" id="read-response"><h2><code>read-response</code></h2></a>
<p>This key specifies the VHDL template for the code block that is
executed when the bus is ready for the response of a previously
deferred read.</p>
<p>The template must perform one of the following actions to respond to
the bus.</p>
<ul>
<li>Set the <code>$ack$</code> boolean variable to <code>true</code>, and the <code>$data$</code>
variable to the read result. <code>$data$</code> is appropriately sliced to
represent the shape of the field; that is, it is sliced to an
<code>std_logic</code> for scalar fields and to an appropriately sized
<code>std_logic_vector</code> for vector fields.</li>
<li>Set the <code>$nack$</code> boolean variable to <code>true</code> to respond with a
slave error.</li>
<li>Set the <code>$block$</code> boolean variable to <code>true</code> to stall. In this
case, the block will be executed again the next cycle. The
<code>read-can-block</code> key must be set in order to use this variable.</li>
<li>Nothing: the bus behaves as if the field does not exist. If there
are no other fields in the addressed register, a decode error is
returned.</li>
</ul>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): no read response code block is needed; multiple outstandingread requests are not supported for this field.</p>
</li>
<li>
<p>a string: insert the given read response code block; this field supports multiple outstanding requests in read mode.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#write" id="write"><h2><code>write</code></h2></a>
<p>This key specifies the VHDL template for the code block that is
executed when the bus is attempting to write to the field while also
ready for the response.</p>
<p>The template must perform one of the following actions to respond to
the bus.</p>
<ul>
<li>Set the <code>$ack$</code> boolean variable to <code>true</code> to respond with an
acknowledgement.</li>
<li>Set the <code>$nack$</code> boolean variable to <code>true</code> to respond with a
slave error.</li>
<li>Set the <code>$block$</code> boolean variable to <code>true</code> to stall. In this
case, the block will be executed again the next cycle. The
<code>write-can-block</code> key must be set in order to use this variable.</li>
<li>Set the <code>$defer$</code> boolean variable to <code>true</code> to defer. In this
case, the request logic will accept the bus request and send
subsequent requests to <code>write-lookahead</code> blocks, while the
response logic will start calling the <code>write-response</code> block to get
the response. Such a <code>write-response</code> block must be specified in
order to use this variable.</li>
<li>Nothing: the bus behaves as if the field does not exist. If there
are no other fields in the addressed register, a decode error is
returned.</li>
</ul>
<p>In addition to the field's interfaces, the template can use the
following variables:</p>
<ul>
<li><code>$data$</code>: the write data for the request, appropriately sliced for
the shape of the field. That is, <code>$data$</code> behaves like an
<code>std_logic</code> for scalar fields, and like an appropriately sized
<code>std_logic_vector</code> for vector fields.</li>
<li><code>$strb$</code>: the write strobe for the request. The variable has the
same shape as <code>$data$</code> and thus behaves as a bit strobe, even though
AXI4L's strobe signal is byte-oriented. If a bit in <code>$strb$</code> is
zero, the respective <code>$data$</code> bit is guaranteed to also be zero, and
should not be written.</li>
<li><code>$prot$</code>: the <code>prot</code> field associated with the request as a
3-bit <code>std_logic_vector</code>.</li>
<li><code>$addr$</code>: the incoming bus address for the request as a 32-bit
<code>std_logic_vector</code>.</li>
<li><code>$sub$</code>: the subaddress for the for the request as an
<code>std_logic_vector</code> slice, of which the width depends on the
field's subaddress configuration.</li>
</ul>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): no write code block is needed.</p>
</li>
<li>
<p>a string: insert the given write code block.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#write-lookahead" id="write-lookahead"><h2><code>write-lookahead</code></h2></a>
<p>This key specifies the VHDL template for the code block that is
executed when the bus is attempting to write to the field, but the
response logic is not yet ready for the response. This can be used to
initiate long transactions a few cycles earlier, or can be used in
conjunction with multiple outstanding request support.</p>
<p>The template must perform one of the following actions to respond to
the bus.</p>
<ul>
<li>Set the <code>$defer$</code> boolean variable to <code>true</code> to defer. In this
case, the request logic will accept the bus request and send
subsequent requests to <code>write-lookahead</code> blocks, while the
response logic will start calling the <code>write-response</code> block to get
the response. Such a <code>write-response</code> block must be specified in
order to use this variable.</li>
<li>Nothing: the bus interface logic will continue to call this block
in subsequent cycles until the response logic is ready, at which
point the regular <code>write</code> block is executed instead.</li>
</ul>
<p>In addition to the field's interfaces, the template can use the
following variables:</p>
<ul>
<li><code>$data$</code>: the write data for the request, appropriately sliced for
the shape of the field. That is, <code>$data$</code> behaves like an
<code>std_logic</code> for scalar fields, and like an appropriately sized
<code>std_logic_vector</code> for vector fields.</li>
<li><code>$strb$</code>: the write strobe for the request. The variable has the
same shape as <code>$data$</code> and thus behaves as a bit strobe, even though
AXI4L's strobe signal is byte-oriented. If a bit in <code>$strb$</code> is
zero, the respective <code>$data$</code> bit is guaranteed to also be zero, and
should not be written.</li>
<li><code>$prot$</code>: the <code>prot</code> field associated with the request as a
3-bit <code>std_logic_vector</code>.</li>
<li><code>$addr$</code>: the incoming bus address for the request as a 32-bit
<code>std_logic_vector</code>.</li>
<li><code>$sub$</code>: the subaddress for the for the request as an
<code>std_logic_vector</code> slice, of which the width depends on the
field's subaddress configuration.</li>
</ul>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): no write lookahead code block is needed.</p>
</li>
<li>
<p>a string: insert the given write lookahead code block.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#write-request" id="write-request"><h2><code>write-request</code></h2></a>
<p>This key specifies the VHDL template for the code block that is
executed when the bus is attempting to write to the field, regardless
of whether the bus is ready for the response. It is up to the code
block itself to check this where needed, using the <code>$resp_ready$</code>
boolean variable. Depending on this boolean, the block must respond to
the access as described in the documentation for the <code>write</code> and
<code>write-lookahead</code> blocks.</p>
<p>While uncommon, both <code>write</code>/<code>write-lookahead</code> and <code>write-request</code> may
be specified at the same time. In this case, <code>write</code>/<code>write-lookahead</code>
is executed before <code>write-request</code>.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): no write request code block is needed.</p>
</li>
<li>
<p>a string: insert the given write request code block.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#write-response" id="write-response"><h2><code>write-response</code></h2></a>
<p>This key specifies the VHDL template for the code block that is
executed when the bus is ready for the response of a previously
deferred write.</p>
<p>The template must perform one of the following actions to respond to
the bus.</p>
<ul>
<li>Set the <code>$ack$</code> boolean variable to <code>true</code> to respond with an
acknowledgement.</li>
<li>Set the <code>$nack$</code> boolean variable to <code>true</code> to respond with a
slave error.</li>
<li>Set the <code>$block$</code> boolean variable to <code>true</code> to stall. In this
case, the block will be executed again the next cycle. The
<code>write-can-block</code> key must be set in order to use this variable.</li>
<li>Nothing: the bus behaves as if the field does not exist. If there
are no other fields in the addressed register, a decode error is
returned.</li>
</ul>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): no write response code block is needed; multiple outstandingwrite requests are not supported for this field.</p>
</li>
<li>
<p>a string: insert the given write response code block; this field supports multiple outstanding requests in write mode.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#post-access" id="post-access"><h2><code>post-access</code></h2></a>
<p>This key specifies the VHDL template for the code block that is
executed each cycle <em>after</em> the bus is accessed. This is usually used
for connecting the internal state to output signals.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): no pre-access code block is needed.</p>
</li>
<li>
<p>a string: insert the given pre-access code block.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#read-can-block" id="read-can-block"><h2><code>read-can-block</code></h2></a>
<p>This key specifies whether the field can block read accesses.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): this field cannot block reads.</p>
</li>
<li>
<p><code>yes</code>: this field can block reads.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#read-volatile" id="read-volatile"><h2><code>read-volatile</code></h2></a>
<p>This key specifies whether the field is volatile in read mode.
<code>vhdmmio</code> defines volatility as the read result or side effects being
different when the field is accessed once versus when it is accessed
more than once.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): this field is not read-volatile.</p>
</li>
<li>
<p><code>yes</code>: this field is read-volatile.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#read-has-side-effects" id="read-has-side-effects"><h2><code>read-has-side-effects</code></h2></a>
<p>This key specifies whether reads have side effects.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): reading this field does not have side effects.</p>
</li>
<li>
<p><code>yes</code>: reading this field may have side effects.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#read-write-related" id="read-write-related"><h2><code>read-write-related</code></h2></a>
<p>This key specifies whether the read data carries the same
significance as the write data. If this is not set, <code>vhdmmio</code> will
never attempt to read-modify-write this field.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the read and write data of this field are not related.</p>
</li>
<li>
<p><code>yes</code>: the read and write data of this field are related.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#write-can-block" id="write-can-block"><h2><code>write-can-block</code></h2></a>
<p>This key specifies whether the field can block write accesses.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): this field cannot block writes.</p>
</li>
<li>
<p><code>yes</code>: this field can block writes.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#write-volatile" id="write-volatile"><h2><code>write-volatile</code></h2></a>
<p>This key specifies whether the field is volatile in write mode.
<code>vhdmmio</code> defines volatility as the write result or side effects being
different when the field is accessed once versus when it is accessed
more than once.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): this field is not write-volatile.</p>
</li>
<li>
<p><code>yes</code>: this field is write-volatile.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#write-no-op" id="write-no-op"><h2><code>write-no-op</code></h2></a>
<p>This key specifies what strategies <code>vhdmmio</code> can use to write the
logical register that this field resides in without affecting this
field, if this is possible at all.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>never</code> (default): it is impossible to write to this field without side effects.</p>
</li>
<li>
<p><code>zero</code>: writing zero to this field never has any side effects (flags).</p>
</li>
<li>
<p><code>current</code>: writing the current value never has any side effects. The current value must either be known from context, or, if <code>read-write-related</code> is set, can be read from the field first (read-modify-write).</p>
</li>
<li>
<p><code>mask</code>: this field can only be masked out using the AXI4L byte strobe signal.</p>
</li>
<li>
<p><code>current-or-mask</code>: this field can be masked out by writing the current value, or through the AXI4L byte strobe signal.</p>
</li>
<li>
<p><code>always</code>: anything goes: writing to this field never has any side effects that <code>vhdmmio</code> has to concern itself with.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>never</code>) is used.</p>
<a class="header" href="#interfaces-for-custom-field-behavior" id="interfaces-for-custom-field-behavior"><h1>Interfaces for <code>custom</code> field behavior</h1></a>
<p>Custom fields can specify any interfaces and state variables they want
to use through this configuration structure. The interface type is
determined based on which of the <code>input</code>, <code>output</code>, <code>generic</code>, <code>drive</code>,
<code>strobe</code>, <code>monitor</code>, and <code>state</code> keys is present to reduce verbosity in the
configuration files; exactly <em>one</em> of these must therefore be specified.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#input" id="input"><h2><code>input</code></h2></a>
<p>Use this key to request an input signal to be generated.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): this interface does not specify an input port.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*</code>: a scalar input port with the specified name is generated. The VHDL identifier for it is made available to the templates through <code>$s.&lt;name&gt;$</code>.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*:[0-9]+</code>: as above, but the port is a vector of the specified width.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#output" id="output"><h2><code>output</code></h2></a>
<p>Use this key to request an output signal to be generated.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): this interface does not specify an output port.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*</code>: a scalar output port with the specified name is generated. The VHDL identifier for it is made available to the templates through <code>$s.&lt;name&gt;$</code>.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*:[0-9]+</code>: as above, but the port is a vector of the specified width.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#generic" id="generic"><h2><code>generic</code></h2></a>
<p>Use this key to request a generic to be generated.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): this interface does not specify a generic.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*</code>: a scalar generic with the specified name is generated. The VHDL identifier for it is made available to the templates through <code>$s.&lt;name&gt;$</code>.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*:[0-9]+</code>: as above, but the generic is a vector of the specified width.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#drive" id="drive"><h2><code>drive</code></h2></a>
<p>Use this key to request an internal signal driven by this field to
be generated.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): this interface does not specify a driven internal.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*</code>: an internal with the specified name is generated and expected to be driven by this field. If the field is not repeated, the signal is scalar, otherwise its width equals the field repetition. The VHDL identifier for it is made available to the templates through <code>$s.&lt;name&gt;$</code>; it always behaves like an <code>std_logic</code>.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*:[0-9]+</code>: as above, but the internal signal is a vector of the specified width. This prevents field repetition from being used.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#strobe" id="strobe"><h2><code>strobe</code></h2></a>
<p>Use this key to request an internal signal strobed by this field to
be generated. A strobed internal should only ever be or'd or written
high!</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): this interface does not specify a strobed internal.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*</code>: an internal with the specified name is generated and expected to be strobed by this field. If the field is not repeated, the signal is scalar, otherwise its width equals the field repetition. The VHDL identifier for it is made available to the templates through <code>$s.&lt;name&gt;$</code>; it always behaves like an <code>std_logic</code>.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*:[0-9]+</code>: as above, but the internal signal is a vector of the specified width. This prevents field repetition from being used.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#monitor" id="monitor"><h2><code>monitor</code></h2></a>
<p>Use this key to request an internal signal monitored by this field
to be generated.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): this interface does not specify a monitored internal.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*</code>: an internal with the specified name is generated and expected to only be read by this field. If the field is not repeated, the signal is scalar, otherwise its width equals the field repetition. The VHDL identifier for it is made available to the templates through <code>$s.&lt;name&gt;$</code>; it always behaves like an <code>std_logic</code>.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*:[0-9]+</code>: as above, but the internal signal is a vector of the specified width. This prevents field repetition from being used.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#state" id="state"><h2><code>state</code></h2></a>
<p>Use this key to request a state variable to be generated.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): this interface does not specify a state variable.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*</code>: a scalar state variable with the specified name is generated. The VHDL identifier for it is made available to the templates through <code>$s.&lt;name&gt;$</code>.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*:[0-9]+</code>: as above, but the state variable is a vector of the specified width.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#type" id="type"><h2><code>type</code></h2></a>
<p>This key specifies the type of the signal. Note that only generics
support <code>natural</code> and <code>boolean</code> types, and only input and output ports
support the <code>axi4l-*-*</code> types.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>std_logic</code> (default): this interface is an <code>std_logic</code> or <code>std_logic_vector</code>.</p>
</li>
<li>
<p><code>natural</code>: this interface is a VHDL <code>natural</code>.</p>
</li>
<li>
<p><code>boolean</code>: this interface is a VHDL <code>boolean</code>.</p>
</li>
<li>
<p><code>axi4l-req-32</code>: this interface is a 32-bit AXI4-lite request structure.</p>
</li>
<li>
<p><code>axi4l-req-64</code>: this interface is a 64-bit AXI4-lite request structure.</p>
</li>
<li>
<p><code>axi4l-resp-32</code>: this interface is a 32-bit AXI4-lite response structure.</p>
</li>
<li>
<p><code>axi4l-resp-64</code>: this interface is a 64-bit AXI4-lite response structure.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>std_logic</code>) is used.</p>
<a class="header" href="#additional-address-match-conditions" id="additional-address-match-conditions"><h1>Additional address match conditions</h1></a>
<p>To support disabling registers at runtime and paged/indirect register
files, <code>vhdmmio</code> allows you to specify additional conditions for the
address matching logic of each register. This may be useful when not
enough address space is allocated to the register file to fit all the
registers, or when you want to emulate legacy register files such as a
16550 UART.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#internal-7" id="internal-7"><h2><code>internal</code></h2></a>
<p>This key specifies the internal signal to use for the match
condition.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*</code>: a scalar internal with the given name is used for the match condition.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*:[0-9]+</code>: a vector internal with the given name and width is used for the match condition.</p>
</li>
</ul>
<p>This key is required.</p>
<a class="header" href="#value-1" id="value-1"><h2><code>value</code></h2></a>
<p>This key specifies the value that the signal must have for the
logical register to be addressed.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>no</code> (default): the signal value needs to be 0.</p>
</li>
<li>
<p><code>yes</code>: the signal value needs to be 1.</p>
</li>
<li>
<p>an integer above or equal to 0: the signal needs to have the specified value.</p>
</li>
<li>
<p>a hex/bin integer with don't cares: the signal value is matched against the given number, specified as a string representation of a hexadecimal or binary integer which may contain don't cares (<code>-</code>). In hexadecimal integers, bit-granular don't-cares can be specified by inserting four-bit binary blocks enclosed in square braces in place of a hex digit.</p>
</li>
<li>
<p><code>&lt;address&gt;/&lt;size&gt;</code>: as before, but the given number of LSBs are ignored in addition.</p>
</li>
<li>
<p><code>&lt;address&gt;|&lt;ignore&gt;</code>: specifies the required signal value and ignored bits using two integers. Both integers can be specified in hexadecimal, binary, or decimal. A bit which is set in the <code>&lt;ignore&gt;</code> value is ignored in the matching process.</p>
</li>
<li>
<p><code>&lt;address&gt;&amp;&lt;mask&gt;</code>: specifies the required signal value and bitmask using two integers. Both integers can be specified in hexadecimal, binary, or decimal. A bit which is not set in the <code>&lt;ignore&gt;</code> value is ignored in the matching process.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>no</code>) is used.</p>
<a class="header" href="#subaddress-components" id="subaddress-components"><h1>Subaddress components</h1></a>
<p><code>vhdmmio</code> fields can encompass more than one address. This allows fields
such as memories and AXI passthrough to exist. Accessing such a field
involves an address in addition to the read and write data. This address is
called a subaddress. This configuration structure specifies part of a
custom subaddress format.</p>
<p>Note that exactly one of the <code>address</code>, <code>internal</code>, and <code>blank</code> keys must
be specified.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#address-1" id="address-1"><h2><code>address</code></h2></a>
<p>This key specifies that this component of the subaddress is based on
bits taken from the incoming address. Normally these bits would be
masked out, but this is not required.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): this subaddress component is not based on the incoming address.</p>
</li>
<li>
<p>an integer between 0 and 31: the specified bit of the incoming address is used.</p>
</li>
<li>
<p><code>&lt;high&gt;..&lt;low&gt;</code>: the specified bitrange of the incoming address is used. The range is inclusive, so the number of bits in the subaddress component is <code>&lt;high&gt;</code> - <code>&lt;low&gt;</code> + 1.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#internal-8" id="internal-8"><h2><code>internal</code></h2></a>
<p>This key specifies that this component of the subaddress is based
on the value of an internal signal.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): this subaddress component is not based on an internal signal.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*</code>: a scalar internal with the given name is inserted into the subaddress at the current position.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*:[0-9]+</code>: a vector internal with the given name and width is inserted into the subaddress at the current position.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#internal-bitrange" id="internal-bitrange"><h2><code>internal-bitrange</code></h2></a>
<p>For component based on vector internal signals, this key allows you
to use only a subset of the signal for this component. In conjunction
with other subaddress components based on the same signal, this allows
bits to be reordered.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the entire vector is used.</p>
</li>
<li>
<p>an integer above or equal to 0: only the specified bit within the vector is used.</p>
</li>
<li>
<p><code>&lt;high&gt;..&lt;low&gt;</code>: the specified subset of the vector is used. The range is inclusive, so the number of bits in the subaddress component is <code>&lt;high&gt;</code> - <code>&lt;low&gt;</code> + 1.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#blank" id="blank"><h2><code>blank</code></h2></a>
<p>This key specifies that a number of blank bits should be inserted as
the next component. The bits are always zero; use the
<code>subaddress-offset</code> key in the field descriptor to set a different
value.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): this subaddress component is not a blank.</p>
</li>
<li>
<p>an integer above or equal to 1: the specified number of blank (zero) bits are inserted.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#permissions" id="permissions"><h1>Permissions</h1></a>
<p>This configuration structure defines the privilege levels that are
allowed to access a field based on the <code>aw_prot</code> and <code>ar_prot</code> AXI4L
signals. This is primarily intended to help you identify problems during
development (such as a softcore deciding to jump to a register file).</p>
<p><strong>If you're using <code>vhdmmio</code> in an environment where security is in any way
meaningful, restrict yourself to using single-word, non-blocking registers.
Even then, <code>vhdmmio</code> has not undergone any kind of auditing or
certification process and therefore does not make ANY guarantees that
your system will be secure.</strong></p>
<p>The following best-effort logic is included based on access privileges:</p>
<ul>
<li>
<p>Accessing a field for which the master has insufficient privileges
makes the field behave like it does not exist. Depending on whether
there are other fields in the surrounding register that can be
accessed, a decode error may or may not be generated. Read data is
always blanked out, and there will not be any side effects.</p>
</li>
<li>
<p>When a higher-privileged master is in the process of accessing a
multi-word register, lower-privileged accesses are rejected. An access
is considered less privileged when the ongoing access is privileged
(<code>--1</code>) while the interrupting access is unprivileged (<code>--0</code>), OR
when the ongoing access is secure (<code>-0-</code>) while the interrupting access
is nonsecure (<code>-1-</code>). Such accesses are rejected by means of a slave
error. Even though it would normally be ignored, the read data is
forced to all zeros during this error to prevent leaks.</p>
</li>
<li>
<p>When a multi-word read completes, the holding register is cleared.</p>
</li>
</ul>
<p>The latter two features may be disabled within the register file features
structure to save a small amount of logic.</p>
<p><code>vhdmmio</code> certainly will <em>NOT</em> protect against:</p>
<ul>
<li>
<p>Timing attacks on blocking fields. This is impossible to avoid by
<code>vhdmmio</code>, since AXI4L does not support reordering.</p>
</li>
<li>
<p>Denial-of-service and man-in-the-middle style attacks for multi-word
accesses on the same privilege level. This is impossible to avoid by
<code>vhdmmio</code>, since AXI4L does not support locking.</p>
</li>
<li>
<p>Powerline side-channel attacks, as well as undervolting, overclocking,
radiation, etc.. Basically, anything that can be used to circumvent the
semantics of VHDL. This is impossible to avoid in a vendor-agnostic way,
and would be extremely difficult even for a specific FPGA/ASIC.</p>
</li>
</ul>
<p>To the best of my knowledge, barring the above, a register file with only
single-word, non-blocking, non-deferring registers should be fairly secure.
But please take this statement with a big grain of salt, as I am not a
security expert.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#user" id="user"><h2><code>user</code></h2></a>
<p>Whether unprivileged masters (<code>--0</code>) can access the field.</p>
<p>The value must be a boolean (default <code>yes</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>yes</code>) is used.</p>
<a class="header" href="#privileged" id="privileged"><h2><code>privileged</code></h2></a>
<p>Whether privileged masters (<code>--1</code>) can access the field.</p>
<p>The value must be a boolean (default <code>yes</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>yes</code>) is used.</p>
<a class="header" href="#secure" id="secure"><h2><code>secure</code></h2></a>
<p>Whether secure transactions (<code>-0-</code>) can be used to can access the
field.</p>
<p>The value must be a boolean (default <code>yes</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>yes</code>) is used.</p>
<a class="header" href="#nonsecure" id="nonsecure"><h2><code>nonsecure</code></h2></a>
<p>Whether nonsecure transactions (<code>-1-</code>) can be used to can access the
field.</p>
<p>The value must be a boolean (default <code>yes</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>yes</code>) is used.</p>
<a class="header" href="#data" id="data"><h2><code>data</code></h2></a>
<p>Whether data transactions (<code>0--</code>) can access the field.</p>
<p>The value must be a boolean (default <code>yes</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>yes</code>) is used.</p>
<a class="header" href="#instruction" id="instruction"><h2><code>instruction</code></h2></a>
<p>Whether instruction transactions (<code>1--</code>) can access the field.</p>
<p>The value must be a boolean (default <code>yes</code>).</p>
<p>This key is optional unless required by context. If not specified, the default value (<code>yes</code>) is used.</p>
<a class="header" href="#interrupt-descriptors" id="interrupt-descriptors"><h1>Interrupt descriptors</h1></a>
<p>In addition to MMIO, <code>vhdmmio</code> can handle interrupt routing for you.
Each AXI4-lite bus is equiped with an additional signal in the
slave-to-master direction that serves as an interrupt request flag. This
flag is connected to a (masked) wired-or network of any incoming interrupts
you define.</p>
<a class="header" href="#behavior-2" id="behavior-2"><h2>Behavior</h2></a>
<p>The interrupts can be monitored and controlled through fields with the
(<code>interrupt</code>)[interrupt.md] behavior.</p>
<p>There are up to three internal registers for each interrupt, named <code>enab</code>
(short for enable), <code>flag</code>, and <code>umsk</code> (short for unmask). <code>enab</code> controls
whether incoming interrupts are passed on to the flag register. The flag
register stores whether the interrupt is pending regardless of whether it
is enabled; if an interrupt comes in while the interrupt is enabled, and
the interrupt is then disabled, the flag remains asserted until it is
explicitly cleared (usually by an interrupt handler). <code>umsk</code> (unmask) has a
similar function, but is placed after the flag register. Thus, masking an
interrupt immediately stops it from being requested, but once the interrupt
is unmasked again, it will be requested again. This logic is shown
schematically below.</p>
<pre><code>            .--[raw&gt;
            |         ____                 flag
IRQ --------o--------|    \     _____     .----.   .-[flag&gt;
                     |     )----\    \    |&gt;   |   |         ____
                  .--|____/      )    )---|S  Q|---o--------|    \     to
           enab   |      [pend&gt;-/____/  .-|R   |  umsk      |     )--&gt; wired
          .----.  |      [clear&gt;--------' '----' .----.  .--|____/     OR
          |&gt;   |  |                              |&gt;   |  |
[enable&gt;--|S  Q|--o--[enabled&gt;          [unmask&gt;-|S  Q|--o--[unmasked&gt;
[disable&gt;-|R   |                        [mask&gt;---|R   |
          '----'                                 '----'
</code></pre>
<p>Each of the three registers are accessible in read, write, set, and clear
modes through fields with (<code>interrupt</code>)[interrupt.md] behavior. The raw
incoming interrupt signal and the masked output signal of an interrupt can
also be monitored directly.</p>
<p>Interrupts can be made level-sensitive by not specifying a way to clear the
interrupt. In this case, the logic is automatically simplified to the
following.</p>
<pre><code>            .--[raw&gt;
            |         ____                 .-[flag&gt;
IRQ --------o--------|    \                |         ____
                     |     )---------------o--------|    \     to
                  .--|____/                         |     )--&gt; wired
           enab   |                       umsk   .--|____/     OR
          .----.  |                      .----.  |
          |&gt;   |  |                      |&gt;   |  |
[enable&gt;--|S  Q|--o--[enabled&gt;  [unmask&gt;-|S  Q|--o--[unmasked&gt;
[disable&gt;-|R   |                [mask&gt;---|R   |
          '----'                         '----'
</code></pre>
<p>Furthermore, if there is no way to enable/unmask an interrupt, the
respective AND gate and the register is effectively optimized away. If
there <em>is</em> a way, the reset state is disabled/masked.</p>
<a class="header" href="#interrupt-sources" id="interrupt-sources"><h2>Interrupt sources</h2></a>
<p>A <code>vhdmmio</code> interrupt can currently be requested through an internal or
synchronous external signal, or by software using the
<a href="interruptpend.html"><code>interrupt-pend</code></a> field behavior. An external
synchronizer is needed to accept asynchronous interrupts. These are often
vendor-specific, therefore they are not included in vhdmmio.</p>
<a class="header" href="#configuration-keys-2" id="configuration-keys-2"><h2>Configuration keys</h2></a>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#repeat-1" id="repeat-1"><h2><code>repeat</code></h2></a>
<p>This value specifies whether this interrupt descriptor describes a
single interrupt or an array of interrupts.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the descriptor describes a single interrupt.</p>
</li>
<li>
<p>an integer above or equal to 1: the descriptor describes an array of interrupts of the given size.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#metadata-keys-1" id="metadata-keys-1"><h2>Metadata keys</h2></a>
<p>This configuration structure is used to name and document the
interrupt.</p>
<p>More information about this structure may be found <a href="metadataconfig.html">here</a>.</p>
<p>The following configuration keys are used to configure this structure.</p>
<a class="header" href="#mnemonic-2" id="mnemonic-2"><h3><code>mnemonic</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#mnemonic">here</a>.</p>
<a class="header" href="#name-2" id="name-2"><h3><code>name</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#name">here</a>.</p>
<a class="header" href="#brief-2" id="brief-2"><h3><code>brief</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#brief">here</a>.</p>
<a class="header" href="#doc-2" id="doc-2"><h3><code>doc</code></h3></a>
<p>This key is documented <a href="metadataconfig.html#doc">here</a>.</p>
<a class="header" href="#internal-9" id="internal-9"><h2><code>internal</code></h2></a>
<p>This key specifies whether the interrupt is requested by an internal
or external signal.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the interrupt request source is an input port.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: the interrupt request source is the internal signal with the given name. The arrayness of the signal must match this interrupt's repetition. Level-sensitive interrupts cannot be associated with strobe signals.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#active" id="active"><h2><code>active</code></h2></a>
<p>This key specifies the event that the interrupt is sensitive to.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>high</code> (default): the interrupt is level/strobe-sensitive, active-high.</p>
</li>
<li>
<p><code>low</code>: the interrupt is level/strobe-sensitive, active-low.</p>
</li>
<li>
<p><code>rising</code>: the interrupt is rising-edge sensitive.</p>
</li>
<li>
<p><code>falling</code>: the interrupt is falling-edge sensitive.</p>
</li>
<li>
<p><code>edge</code>: the interrupt is sensitive to any edge.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>high</code>) is used.</p>
<a class="header" href="#group-2" id="group-2"><h2><code>group</code></h2></a>
<p>The interrupt request port for the internal signal can optionally be
grouped along with other ports in a record. This key specifies the name
of the group record.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): port grouping is determined by the global default.</p>
</li>
<li>
<p><code>no</code>: the port is not grouped in a record.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: the port is grouped in a record with the specified name.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#internal-signal-io" id="internal-signal-io"><h1>Internal signal I/O</h1></a>
<p>While vhdMMIO's field types and interrupts are already quite powerful on
their own, their full power is only truly unlocked when they are used
together. For instance, you may want to trigger an interrupt when a bus
write occurs to an MMIO-to-stream field while the stream is blocked, to
notify the software that it did something wrong. To support this and more
without needing some external boilerplate logic (after all, the goal is to
reduce such boilerplate logic as much as possible!), vhdMMIO supports
specification of custom &quot;internal&quot; signals.</p>
<p>An internal signal is automatically inferred when its name is referenced by
an event source or sink. The name acts as a unique identifier, so
specifying the same name twice will result in the components being tied
together.</p>
<p>Internal signals can be scalars (<code>std_logic</code>) or vectors
(<code>std_logic_vector</code>), and can be level-based with a single driver, or
strobe/event-based with one or more event sources (sometimes called
<code>strobers</code>). The kind of internal signal that's associated with a name is
usually implied by context. Of course, all endpoints that refer to an
internal must agree to its kind, or vhdMMIO will send an error message your
way.</p>
<p>Sometimes, you may want to use or drive an data source or sink outside the
register file. For instance, there may be a page register outside the
register file that you want to use to select which page of registers is
accessible. That's where this configuration structure comes in: it lets you
associate a port with an internal signal, essentially making it an external
signal.</p>
<p>This structure supports the following configuration keys.</p>
<a class="header" href="#direction" id="direction"><h2><code>direction</code></h2></a>
<p>This key specifies what kind of I/O port should be made for the
internal signal specified by <code>internal</code>.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>input</code>: an input port is generated for the internal. This  must be the internal signal's only driver.</p>
</li>
<li>
<p><code>strobe</code>: an strobe input port is generated for the internal. The internal can be driven by other strobe sources as well; the result is wired-or.</p>
</li>
<li>
<p><code>output</code>: an input port is generated for the internal.</p>
</li>
</ul>
<p>This key is required.</p>
<a class="header" href="#internal-10" id="internal-10"><h2><code>internal</code></h2></a>
<p>This key specifies the name and shape of the internal signal.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*</code>: a port is generated for a scalar internal with the given name.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*:[0-9]+</code>: a port is generated for a vector internal with the given name and width.</p>
</li>
</ul>
<p>This key is required.</p>
<a class="header" href="#port" id="port"><h2><code>port</code></h2></a>
<p>This key specifies the name of the port.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): the port is named after the internal signal.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Za-z][a-zA-Z0-9_]*</code>: the specified name is used for the port, regardless of the name of the internal signal.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>
<a class="header" href="#group-3" id="group-3"><h2><code>group</code></h2></a>
<p>The I/O port for the internal signal can optionally be grouped
along with other ports in a record. This key specifies the name of the
group record.</p>
<p>The following values are supported:</p>
<ul>
<li>
<p><code>null</code> (default): port grouping is determined by the global default.</p>
</li>
<li>
<p><code>no</code>: the port is not grouped in a record.</p>
</li>
<li>
<p>a string matching <code>[a-zA-Z][a-zA-Z0-9_]*</code>: the port is grouped in a record with the specified name.</p>
</li>
</ul>
<p>This key is optional unless required by context. If not specified, the default value (<code>null</code>) is used.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
