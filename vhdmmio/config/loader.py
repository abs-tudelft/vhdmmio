"""Submodule containing the `Loader` and `ScalarLoader` base classes. Each
`Loader` represents one or more keys in a configuration dictionary in
serialized form, or one `@property` in deserialized/internal form. Their
specializations (define in other submodules) are added to a `Configurable`
class through annotations, similar to how the `@property` annotation works."""

import textwrap
import copy
from .utils import Unset, ParseError, friendly_path, friendly_yaml_value

class Loader:
    """Base class for configuration key loaders."""

    _ORDER = 0

    def __init__(self, key, doc):
        super().__init__()
        self._order = Loader._ORDER
        Loader._ORDER += 1
        self._key = key
        self._doc = textwrap.dedent(doc)

    @property
    def order(self):
        """Ordering key to get the order in which loaders are defined."""
        return self._order

    @property
    def key(self):
        """The key that this `Loader` operates on."""
        return self._key

    @property
    def friendly_key(self):
        """"Friendly" version of the  key that this `Loader` operates on, using
        dashes instead of underscores."""
        return self._key.replace('_', '-')

    @property
    def doc(self):
        """Documentation for the configuration parameter loaded by this
        `Loader`."""
        return self._doc

    def friendly_path(self, path=()):
        """Pretty-prints a key name and the path leading up to it for error
        messages etc."""
        return friendly_path(path + (self.friendly_key,))

    def markdown(self):
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""
        yield self.friendly_key, self.doc

    @staticmethod
    def markdown_more():
        """Yields or returns a list of `@configurable` classes that must be
        documented in addition because the docs generated by `markdown()` refer
        to them."""
        return []

    @staticmethod
    def pop_dict(dictionary, key, path=()):
        """Convenience function that pops a value from a configuration
        dictionary, raising an appropriate `ParseError` message if it does not
        exist."""
        if key not in dictionary:
            raise ParseError(
                '%s is a required parameter'
                % friendly_path(path + (key.replace('_', '-'),)))
        return dictionary.pop(key)

    @staticmethod
    def deserialize(dictionary, parent, path=()):
        """Deserializes the part of the configuration dictionary `dictionary`
        handled by this loader. `parent` is a reference to the parent class
        instance itself, but be aware that it has not been fully initialized
        yet (since we're in the middle of initializing it when this is called.
        `path` optionally specifies an iterable of previous dictionary
        keys/list indices all the way down to the root of the configuration
        file, which may be used for error messages. This function removes any
        keys it recognizes from the configuration dictionary, so once all
        `Loader`s have been called, the dictionary should be empty. The
        deserialized value is returned, or an appropriate, user-friendly error
        message is returned by means of an exception."""

    @staticmethod
    def serialize(dictionary, value):
        """Serializes a value returned by `deserialize()` back into its
        configuration form. `dictionary` is the `dict` that must be updated
        with the configuration keys, `value` is the deserialized value."""


class ScalarLoader(Loader):
    """Base class for scalar configuration key loaders, i.e. loaders that
    operate on a single value in the given dictionary. The value may have a
    default that will automatically be substituted when the value is fetched
    using `get_value()`, or it may not have a default, in which case an
    appropriate error is produced when the value is fetched. `ScalarLoader`s
    can also be updated with a different default value or override for child
    classes."""

    def __init__(self, key, markdown, default=Unset, override=Unset):
        super().__init__(key, markdown)
        self._default = default
        self._override = override

    @property
    def default(self):
        """The default value, or `Unset` if there is no default."""
        return self._default

    def has_default(self):
        """Returns whether this loader has a default value."""
        return self.default is not Unset

    def set_default(self, value):
        """Returns a copy of this loader with the default value modified to
        the given value."""
        result = copy.copy(self)
        result._default = value #pylint: disable=W0212
        return result

    @property
    def override_value(self):
        """The override value, or `Unset` if there is no override."""
        return self._override

    def is_overridden(self):
        """Returns whether this loader has an override value. In this case,
        `serialize()` should be no-op."""
        return self.override_value is not Unset

    def override(self, value):
        """Returns a copy of this loader with the override value modified to
        the given value."""
        result = copy.copy(self)
        result._override = value #pylint: disable=W0212
        return result

    def get_value(self, dictionary, path=()):
        """Pops the value for this loader from the given dictionary,
        respecting the default and override values. Raises a user-friendly
        error using `path` if the value in the dictionary is missing or not
        equal to the override value."""
        if self.is_overridden():
            value = dictionary.pop(self.key, self.override_value)
            if value != self.override_value:
                raise ParseError('%s must be %s or be left unspecified' % (
                    self.friendly_path(path), friendly_yaml_value(self.override_value)))
            return value
        if self.has_default():
            return dictionary.pop(self.key, self.default)
        return self.pop_dict(dictionary, self.key, path)

    def serialize(self, dictionary, value):
        """`ScalarLoader` serializer. See `Loader.serialize()` for more info."""
        if self.is_overridden():
            return
        value = self.scalar_serialize(value)
        if value != self.default:
            dictionary[self.key] = value

    @staticmethod
    def scalar_serialize(value):
        """Converts the internal value into its serialized representation."""
        return value

    def markdown(self):
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""
        if self.is_overridden():
            return
        markdown = [self.doc]
        markdown.extend(self.scalar_markdown())
        if self.has_default():
            markdown.append('This key is optional unless required by context. '
                            'If not specified, the default value (%s) is used.' %
                            friendly_yaml_value(self.default))
        else:
            markdown.append('This key is required.')
        yield self.friendly_key, '\n\n'.join(markdown)

    @staticmethod
    def scalar_markdown():
        """Can be overridden to return or yield additional markdown paragraphs
        for this configuration key."""
        return []
