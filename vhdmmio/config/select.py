"""Submodule for the `Select` `Loader`. This loader works like a `SubConfig`,
but uses an additional key in the dictionary to select which configurable to
instantiate."""

import textwrap
from collections import OrderedDict
from .loader import Loader
from .utils import ParseError, Unset, friendly_yaml_value

class Select(Loader):
    """Loader for embedding `Configurable`s, with multiple different kinds of
    possible `Configurable` classes, based on an additional selection key.

    The class is constructed with a reference to its parent as its first
    and only positional argument. Any keys that have been parsed before can be
    read from this for contextual information."""

    def __init__(self, key, doc, config_options):
        super().__init__(key, doc)
        self._config_options = config_options

    def markdown(self):
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""
        markdown = [self.doc]

        markdown.append('This key can take the following values:')

        for value, (_, doc) in self._config_options.items():
            markdown.append(' - `%s`: %s' % (
                value, textwrap.dedent(doc).replace('\n', '\n   ')))

        yield self.key, markdown

    def markdown_more(self):
        """Yields or returns a list of `@configurable` classes that must be
        documented in addition because the docs generated by `markdown()` refer
        to them."""
        for configurable, _ in self._config_options:
            yield configurable

    def deserialize(self, dictionary, parent):
        """`Select` deserializer. See `Loader.deserialize()` for more
        info."""
        selection = dictionary.pop(self.key, Unset)
        if selection is Unset:
            ParseError.required(self.key)
        configurable, _ = self._config_options.get(selection, (None, None))
        if configurable is None:
            ParseError.invalid(
                self.key, selection,
                *map(friendly_yaml_value, self._config_options))
        item = configurable(parent, dictionary)
        assert type(item) is configurable #pylint: disable=C0123
        return item

    def serialize(self, dictionary, value):
        """`Select` serializer. See `Loader.serialize()` for more info."""
        selection = None
        for selection, configurable in self._config_options.items():
            if type(value) is configurable: #pylint: disable=C0123
                break
        else:
            selection = None
        assert selection is not None
        dictionary[self.key] = selection
        value.serialize(dictionary)

    def mutable(self):
        """Returns whether the value managed by this loader can be mutated. If
        this is overridden to return `True`, the loader must implement
        `validate()`."""
        return True

    def validate(self, value):
        """Checks that the given value is valid for this loader, raising an
        appropriate ParseError if not. This function only needs to work if
        `mutable()` returns `True`."""
        for configurable in self._config_options.values():
            # Note: an exact typecheck is used in order to ensure that
            # serialization followed by deserialization results in the same
            # value. Also, the configurables in the mapping could be instances
            # of each other.
            if type(value) is configurable: #pylint: disable=C0123
                break
        else:
            raise TypeError('type of value must be one of the configurable options')
        if value.parent is not self:
            raise ValueError('value must have been initialized with us as the parent')


def select(method):
    """Method decorator for configuring a `configurable`-annotated class
    selected through another configuration value. The annotated method is
    called with zero arguments (not even `self`) to generate/yield
    `(value, configurable, doc)` three-tuples, where `value` is the unique
    value that the user must specify to select `configurable`, and `doc` is the
    documentation associated with this option. The method is transformed to a
    property that allows the constructed configurable instance to be
    accessed."""
    return Select(
        method.__name__, method.__doc__, OrderedDict((
            (value, (configurable, doc))
            for value, configurable, doc in method())))
