"""Submodule for the `SubConfig` `Loader`, which can be used to
create/configure hierarchical object structures in various ways."""

import copy
from .loader import Loader
from .utils import ParseError

class ListConfig(Loader):
    """Loader for lists of `Configurable`s. This loader takes a single key from
    its configuration dictionary, which must be a list of dictionaries. These
    dictionaries are normally used to configure the target `Configurable`
    classes. Alternatively, the dictionaries can again contain a list of
    dictionaries with a specific name which are parsed into the `Configurable`s
    instead, using the original dictionary as a prototype.

    The class is constructed with a reference to its parent as its first and
    only positional argument. Any keys that have been parsed before can be read
    from this for contextual information."""

    def __init__(self, key, doc, configurable, subkey=None):
        super().__init__(key, doc)
        self._configurable = configurable
        self._subkey = subkey

    @property
    def subkey(self):
        """The prototype subkey for this loader, or `None` if this feature is
        disabled."""
        return self._subkey

    def markdown(self):
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""
        cfg_fname = '%s.md' % self._configurable.__name__.lower()

        markdown = [self.doc]

        markdown.append(
            'This key must be set to a list of dictionaries, of which the '
            'structure is defined [here](%s).' % cfg_fname)

        if self.subkey is not None:
            markdown[-1] += (
                ' In addition, the `%s` key can be used to define the list '
                'elements as a tree; if it is present in one of the '
                'dictionaries, the dictionary becomes a non-leaf node, with '
                'the `%s` key specifying the list of child nodes. This tree '
                'is flattened during parsing, in such a way that the '
                'configuration for a flattened node becomes the root '
                'dictionary, updated with its child dictionary, all the way '
                'down to the leaf node; the non-leaf nodes essentially set '
                'the default values for their children. For example,'
                % (self.subkey, self.subkey))
            markdown.append(
                '```\n'
                '%s:\n'
                '- a: 1\n'
                '  b: 2\n'
                '  c: 3\n'
                '  %s:\n'
                '  - a: 5\n'
                '  - d: 4\n'
                '```' % (self.key, self.subkey))
            markdown.append('is equivalent to')
            markdown.append(
                '```\n'
                '%s:\n'
                '- a: 5\n'
                '  b: 2\n'
                '  c: 3\n'
                '- a: 1\n'
                '  b: 2\n'
                '  c: 3\n'
                '  d: 4\n'
                '```' % self.key)
            markdown.append(
                'This can be useful for specifying repetetive structures.')

        markdown.append(
            'This key is optional. Not specifying it is equivalent to '
            'specifying an empty list.')

        yield self.key, '\n\n'.join(markdown)

    def markdown_more(self):
        """Yields or returns a list of `@configurable` classes that must be
        documented in addition because the docs generated by `markdown()` refer
        to them."""
        yield self._configurable

    def _handle_list(self, config_list, parent, prototype=None):
        """Handles a list of subconfigs, yielding the deserialized objects."""

        # Verify that we got a list.
        if not isinstance(config_list, list):
            ParseError.invalid('', config_list, [])

        for index, subdict in enumerate(config_list):
            with ParseError.wrap(index):

                # Verify that the list entry is a dictionary.
                if not isinstance(subdict, dict):
                    ParseError.invalid('', config_list, [])

                # Merge the dictionary with the prototype, if there is one.
                if prototype:
                    updated_prototype = copy.deepcopy(prototype)
                    updated_prototype.update(subdict)
                    subdict = updated_prototype

                # Handle the next level of prototypes, if there is one.
                if self.subkey is not None and self.subkey in subdict:
                    sublist = subdict.pop(self.subkey)
                    with ParseError.wrap(self.subkey):
                        generator = self._handle_list(sublist, parent, subdict)
                        for item in generator:
                            yield item
                    continue

                # Pass the final dict to the configurable for deserialization.
                yield self._configurable(parent, subdict)

                # Trip over unknown keys.
                if subdict:
                    ParseError.unknown(*subdict)

    def deserialize(self, dictionary, parent):
        """`ListConfig` deserializer. See `Loader.deserialize()` for more
        info."""
        with ParseError.wrap(self.key):
            return ProtectedList(
                self._configurable,
                self._handle_list(dictionary.pop(self.key, []), parent))

    def serialize(self, dictionary, value):
        """`ListConfig` serializer. See `Loader.serialize()` for more info."""
        dictionary[self.key] = [item.serialize() for item in value]

    @staticmethod
    def freeze(value):
        """Prevents the value managed by this loader (passed to the method)
        from being mutated further."""
        value.freeze()


class ProtectedList:
    """Wrapper for Python list that ensures that the type of objects added to
    it match the expected type."""

    def __init__(self, configurable, initial=None):
        super().__init__()
        self._configurable = configurable
        self._list = []
        self._frozen = False
        if initial is not None:
            self.extend(initial)

    @property
    def frozen(self):
        """Returns whether this list has been frozen."""
        return self._frozen

    def freeze(self):
        """Freezes the contents of this list."""
        self._frozen = True
        for item in self._list:
            item.freeze()

    def _mutable_check(self):
        """Raises an exception if we're frozen."""
        if self.frozen:
            raise ValueError('cannot mutate frozen protected list')

    def _validate(self, value):
        """Checks the type of the given value to make sure it can go into the
        list."""

        # Note: an exact typecheck is used in order to ensure that
        # serialization followed by deserialization results in the same value.
        if type(value) is not self._configurable: #pylint: disable=C0123
            raise TypeError(
                'cannot insert value of type %s into list, must be %s'
                % (type(value).__name__, self._configurable.__name__))

    def __len__(self):
        return len(self._list)

    def __getitem__(self, index):
        return self._list[index]

    def __setitem__(self, index, value):
        self._mutable_check()
        self._validate(value)
        self._list[index] = value

    def __delitem__(self, index):
        self._mutable_check()
        del self._list[index]

    def __iter__(self):
        return iter(self._list)

    def __reversed__(self):
        return reversed(self._list)

    def __contains__(self, value):
        return value in self._list

    def append(self, value):
        """Appends to the internal list, ensuring value is acceptable."""
        self._mutable_check()
        self._validate(value)
        self._list.append(value)

    def extend(self, iterable):
        """Extends the internal list, ensuring value is acceptable."""
        self._mutable_check()
        for value in iterable:
            self.append(value)

    def insert(self, index, value):
        """Inserts into the internal list, ensuring value is acceptable."""
        self._mutable_check()
        self._validate(value)
        self._list.insert(index, value)

    def remove(self, value):
        """Removes a value from the list."""
        self._mutable_check()
        self._list.remove(value)

    def pop(self, index=-1):
        """Pops a value from the list."""
        self._mutable_check()
        return self._list.pop(index)

    def clear(self):
        """Clears the list."""
        self._mutable_check()
        self._list.clear()

    def index(self, *args):
        """Chains to list.index()."""
        return self._list.index(*args)

    def count(self, value):
        """Chains to list.count()."""
        return self._list.count(value)

    def sort(self, *args, **kwargs):
        """Chains to list.sort()."""
        self._mutable_check()
        return self._list.sort(*args, **kwargs)

    def reverse(self):
        """Chains to list.reverse()."""
        self._mutable_check()
        return self._list.reverse()

    def copy(self):
        """Returns a shallow copy of this protected list."""
        return ProtectedList(self._configurable, self._list)


def listconfig(method):
    """Method decorator for configuring a list of `configurable`-annotated
    objects. The annotated method is called with zero arguments (not even
    `self`) to get the class that is to be constructed. The name of the key is
    set to the name of the method, and the markdown documentation for the key
    is set to the method's docstring."""
    return ListConfig(method.__name__, method.__doc__, method())


def protolistconfig(method):
    """Like `@listconfig`, but supports prototypes. The prototype key is set
    to the name of the method with `'sub'` prefixed to it."""
    return ListConfig(method.__name__, method.__doc__, method(), 'sub' + method.__name__)
