"""Submodule containing the `Loader` and `ScalarLoader` base classes. Each
`Loader` represents one or more keys in a configuration dictionary in
serialized form, or one `@property` in deserialized/internal form. Their
specializations (define in other submodules) are added to a `Configurable`
class through annotations, similar to how the `@property` annotation works."""

import copy
import inspect
from .utils import Unset, ParseError, friendly_yaml_value

class Loader:
    """Base class for configuration key loaders."""

    # Since it's impossible to determine method definition order before Python
    # 3.6, we keep track of our own (global) counter and use that as a sorting
    # key.
    _ORDER = 0

    def __init__(self, key, doc):
        super().__init__()
        self._key = key.replace('_', '-')
        self._doc = inspect.cleandoc(doc)

        # Claim and update sorting key.
        self._order = Loader._ORDER
        Loader._ORDER += 1

    @property
    def order(self):
        """Ordering key to get the order in which loaders are defined."""
        return self._order

    @order.setter
    def order(self, value):
        """Allows setting the order."""
        self._order = value

    @property
    def key(self):
        """The key that this `Loader` operates on."""
        return self._key

    @property
    def doc(self):
        """Documentation for the configuration parameter loaded by this
        `Loader`."""
        return self._doc

    def markdown(self):
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""
        yield self.key, self.doc

    @staticmethod
    def markdown_more():
        """Yields or returns a list of `@configurable` classes that must be
        documented in addition because the docs generated by `markdown()` refer
        to them."""
        return []

    @staticmethod
    def deserialize(dictionary, parent):
        """Deserializes the part of the configuration dictionary `dictionary`
        handled by this loader. `parent` is a reference to the parent class
        instance itself, but be aware that it has not been fully initialized
        yet (since we're in the middle of initializing it when this is called.
        `path` optionally specifies an iterable of previous dictionary
        keys/list indices all the way down to the root of the configuration
        file, which may be used for error messages. This function removes any
        keys it recognizes from the configuration dictionary, so once all
        `Loader`s have been called, the dictionary should be empty. The
        deserialized value is returned, or an appropriate, user-friendly error
        message is returned by means of an exception."""
        raise NotImplementedError()

    @staticmethod
    def serialize(dictionary, value):
        """Serializes a value returned by `deserialize()` back into its
        configuration form. `dictionary` is the `dict` that must be updated
        with the configuration keys, `value` is the deserialized value."""
        raise NotImplementedError()

    @staticmethod
    def mutable():
        """Returns whether the value managed by this loader can be mutated. If
        this is overridden to return `True`, the loader must implement
        `validate()`."""
        return False

    @staticmethod
    def validate(_):
        """Checks that the given value is valid for this loader, raising an
        appropriate ParseError if not. This function only needs to work if
        `mutable()` returns `True`."""

    @staticmethod
    def freeze(_):
        """Prevents the value managed by this loader (passed to the method)
        from being mutated further."""


class ScalarLoader(Loader):
    """Base class for scalar configuration key loaders, i.e. loaders that
    operate on a single value in the given dictionary. The value may have a
    default that will automatically be substituted when the value is fetched
    using `get_value()`, or it may not have a default, in which case an
    appropriate error is produced when the value is fetched. `ScalarLoader`s
    can also be updated with a different default value or override for child
    classes."""

    def __init__(self, key, markdown, default=Unset, override=Unset):
        super().__init__(key, markdown)
        self._default = default
        self._override = override

    @property
    def default(self):
        """The default value, or `Unset` if there is no default."""
        return self._default

    def has_default(self):
        """Returns whether this loader has a default value."""
        return self.default is not Unset

    def with_default(self, value):
        """Returns a copy of this loader with the default value modified to
        the given value."""
        result = copy.copy(self)
        result._default = value #pylint: disable=W0212
        return result

    @property
    def override(self):
        """The override value, or `Unset` if there is no override."""
        return self._override

    def has_override(self):
        """Returns whether this loader has an override value. In this case,
        `serialize()` should be no-op."""
        return self.override is not Unset

    def with_override(self, value):
        """Returns a copy of this loader with the override value modified to
        the given value."""
        result = copy.copy(self)
        result._override = value #pylint: disable=W0212
        return result

    def get_value(self, dictionary):
        """Pops the value for this loader from the given dictionary,
        respecting the default and override values. Raises a user-friendly
        error using `path` if the value in the dictionary is missing or not
        equal to the override value."""
        if self.has_override():
            value = dictionary.pop(self.key, self.override)
            if value != self.override:
                ParseError.invalid(
                    self.key, value,
                    friendly_yaml_value(self.override),
                    friendly_yaml_value(Unset))
            return value
        value = dictionary.pop(self.key, self.default)
        if not self.has_default() and value is Unset:
            ParseError.required(self.key)
        return value

    @staticmethod
    def deserialize(dictionary, parent):
        """See `Loader.deserialize()`."""
        raise NotImplementedError()

    def serialize(self, dictionary, value):
        """`ScalarLoader` serializer. See `Loader.serialize()` for more info."""
        if self.has_override():
            return
        value = self.scalar_serialize(value)
        if value != self.default:
            dictionary[self.key] = value

    @staticmethod
    def scalar_serialize(value):
        """Converts the internal value into its serialized representation."""
        return value

    def markdown(self):
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""

        # Don't document overridden keys. We condone the user specifying them
        # if the value is correct, but it's not exactly recommended.
        if self.has_override():
            return

        markdown = [self.doc]
        markdown.extend(self.scalar_markdown())

        # Automatically generate as much as we can.
        if not self.has_default():
            markdown.append('This key is required.')
        elif self.default is Unset:
            markdown.append('This key is optional unless required by context.')
        else:
            markdown.append('This key is optional unless required by context. '
                            'If not specified, the default value (%s) is used.' %
                            friendly_yaml_value(self.default))

        yield self.key, '\n\n'.join(markdown)

    @staticmethod
    def scalar_markdown():
        """Can be overridden to return or yield additional markdown paragraphs
        for this configuration key."""
        return []
