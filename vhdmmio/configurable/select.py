"""Submodule for the `Select` `Loader`. This loader works like a `SubConfig`,
but uses an additional key in the dictionary to select which configurable to
instantiate."""

import textwrap
from .loader import Loader
from .utils import ParseError, Unset, friendly_yaml_value

class Select(Loader):
    """Loader for embedding `Configurable`s, with multiple different kinds of
    possible `Configurable` classes, based on an additional selection key.

    The class is constructed with a reference to its parent as its first
    and only positional argument. Any keys that have been parsed before can be
    read from this for contextual information."""

    def __init__(self, key, doc, *options):
        super().__init__(key, doc)
        self._config_options = {name: cls for name, cls, _, _ in options if name is not None}
        self._option_doc = options

    def markdown(self):
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""
        markdown = [self.doc]

        markdown.append('This key can take the following values:')

        for value, cfg, doc, level in self._option_doc:
            if value is None:
                value = ''
            else:
                cfg_fname = '%s.md' % cfg.__name__.lower()
                value = '[`%s`](%s): ' % (value, cfg_fname)
            markdown.append('%s - %s%s' % (
                '   ' * level, value, textwrap.dedent(doc).replace('\n', '\n   ')))

        markdown.append(
            'Depending on the value, additional configuration keys may be '
            'supported or required. These must be specified in the same '
            'dictionary that this key resides in. Refer to the documentation '
            'for the individual values for more information.')

        yield self.key, '\n\n'.join(markdown)

    def markdown_more(self):
        """Yields or returns a list of `@configurable` classes that must be
        documented in addition because the docs generated by `markdown()` refer
        to them."""
        for configurable in self._config_options.values():
            yield configurable

    def deserialize(self, dictionary, parent):
        """`Select` deserializer. See `Loader.deserialize()` for more
        info."""
        selection = dictionary.pop(self.key, Unset)
        if selection is Unset:
            ParseError.required(self.key)
        configurable = self._config_options.get(selection, (None, None))
        if configurable is None:
            ParseError.invalid(
                self.key, selection,
                *map(friendly_yaml_value, self._config_options))
        item = configurable(parent, dictionary)
        assert type(item) is configurable #pylint: disable=C0123
        return item

    def serialize(self, dictionary, value):
        """`Select` serializer. See `Loader.serialize()` for more info."""
        selection = None
        for selection, configurable in self._config_options.items():
            if type(value) is configurable: #pylint: disable=C0123
                break
        else:
            selection = None
        assert selection is not None
        dictionary[self.key] = selection
        value.serialize(dictionary)

    def mutable(self):
        """Returns whether the value managed by this loader can be mutated. If
        this is overridden to return `True`, the loader must implement
        `validate()`."""
        return True

    def validate(self, value):
        """Checks that the given value is valid for this loader, raising an
        appropriate ParseError if not. This function only needs to work if
        `mutable()` returns `True`."""
        for configurable in self._config_options.values():
            # Note: an exact typecheck is used in order to ensure that
            # serialization followed by deserialization results in the same
            # value. Also, the configurables in the mapping could be instances
            # of each other.
            if type(value) is configurable: #pylint: disable=C0123
                break
        else:
            raise TypeError('type of value must be one of the configurable options')
        if value.parent is not self:
            raise ValueError('value must have been initialized with us as the parent')

    @staticmethod
    def freeze(value):
        """Prevents the value managed by this loader (passed to the method)
        from being mutated further."""
        value.freeze()


def select(method):
    """Method decorator for configuring a `configurable`-annotated class
    selected through another configuration value. The annotated method is
    called with zero arguments (not even `self`) to generate/yield
    `(value, configurable, doc)` three-tuples, where `value` is the unique
    value that the user must specify to select `configurable`, and `doc` is the
    documentation associated with this option. The method is transformed to a
    property that allows the constructed configurable instance to be
    accessed."""
    return Select(method.__name__, method.__doc__, *method())
