"""Submodule with base classes for JSON/YAML-configurable objects."""

import re
import textwrap

class Loader:
    """Base class for configuration key loaders."""

    def __init__(self, key, doc):
        super().__init__()
        self._key = key
        self._doc = textwrap.dedent(doc)

    @property
    def key(self):
        """The key that this `Loader` operates on."""
        return self._key

    @property
    def friendly_key(self):
        """"Friendly" version of the  key that this `Loader` operates on, using
        dashes instead of underscores."""
        return self._key.replace('_', '-')

    @property
    def doc(self):
        """Documentation for the configuration parameter loaded by this
        `Loader`."""
        return self._doc

    def friendly_path(self, path=()):
        """Pretty-prints a key name and the path leading up to it for error
        messages etc."""
        path = path + (self.friendly_key,)
        pretty = []
        for entry in path:
            if isinstance(entry, int) and pretty:
                pretty[-1] += '[%d]' % entry
            else:
                pretty.append(str(entry).replace('_', '-'))
        return '.'.join(pretty)

    def pop_dict(self, dictionary, key, path=()):
        """Convenience function that pops a value from a configuration
        dictionary, raising an appropriate `KeyError` message if it does not
        exist."""
        if key not in dictionary:
            raise KeyError('%s is a required parameter' % self.friendly_path(path))
        return dictionary.pop(key)

    @staticmethod
    def deserialize(dictionary, path=()):
        """Deserializes the part of the configuration dictionary `dictionary`
        handled by this loader. `path` optionally specifies an iterable of
        previous dictionary keys/list indices all the way down to the root of
        the configuration file, which may be used for error messages. This
        function removes any keys it recognizes from the configuration
        dictionary, so once all `Loader`s have been called, the dictionary
        should be empty. The deserialized value is returned, or an appropriate,
        user-friendly error message is returned by means of an exception."""

    @staticmethod
    def serialize(dictionary, value):
        """Serializes a value returned by `deserialize()` back into its
        configuration form. `dictionary` is the `dict` that must be updated
        with the configuration keys, `value` is the deserialized value."""

    @staticmethod
    def markdown():
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""
        #pylint: disable=W0101
        return
        yield

    @staticmethod
    def markdown_more():
        """Returns a list of `@configurable` classes that must be documented
        in addition because the docs generated by `markdown()` refer to
        them."""
        return []

    @classmethod
    def decorator(cls, *args, **kwargs):
        """Returns a decorator for this `Loader` that turns an (empty) method
        into a configurable property."""
        def fun(method):
            return cls(method.__name__, method.__doc__, *args, **kwargs)
        return fun


class Choice(Loader):
    """Loader for regular keys, where a user can choose between a number of
    options, of which the first one is the default. Choices are specified as
    `(spec, markdown)` tuples, where `spec` is an integer, boolean, or string
    that must match exactly, `None` for `null`, a compiled regex object that
    must match, a two-tuple specifying a valid integer range, a type (so only
    the type has to match), or a function that does the conversion, and
    `markdown` is the documentation for what that value does. The first choice
    must be an exact value or `None`. A conversion function may only be used
    for the last argument. For conversion functions, the documentation is
    generated from the function's docstring. Conversion function must return
    something whose `str()` representation performs the inverse of the
    conversion function."""

    def __init__(self, key, markdown, *choices):
        super().__init__(key, markdown)
        self._choices = choices
        self._default = choices[0][0]
        if not isinstance(self._default, (int, str, bool)) and self._default is not None:
            raise ValueError('invalid default value')

        friendly_choices = []
        ints_found = False
        strings_found = False
        bools_found = False
        function_found = False

        for choice, _ in self._choices:
            if function_found:
                raise ValueError('interpreter function must be the last choice')

            if isinstance(choice, int):
                friendly_choices.append('`%d`' % choice)
                ints_found = True

            elif isinstance(choice, str):
                friendly_choices.append('`%s`' % choice)
                strings_found = True

            elif isinstance(choice, bool):
                if choice:
                    friendly_choices.append('`true`')
                else:
                    friendly_choices.append('`false`')
                bools_found = True

            elif choice is None:
                friendly_choices.append('`null`')

            elif hasattr(choice, 'fullmatch'):
                friendly_choices.append('a string matching `%s`' % choice.pattern)
                strings_found = True

            elif isinstance(choice, tuple):
                if choice[0] is None:
                    if choice[1] is None:
                        if ints_found:
                            friendly_choices.append('a different integer')
                        else:
                            friendly_choices.append('an integer')
                    else:
                        friendly_choices.append('an integer below %d' % choice[1])
                elif choice[1] is None:
                    friendly_choices.append('an integer above or equal to %d' % choice[0])
                else:
                    friendly_choices.append('an integer between %d and %d' % choice)
                ints_found = True

            elif issubclass(choice, int):
                if ints_found:
                    friendly_choices.append('a different integer')
                else:
                    friendly_choices.append('an integer')

            elif issubclass(choice, str):
                if strings_found:
                    friendly_choices.append('a different string')
                else:
                    friendly_choices.append('a string')

            elif issubclass(choice, bool):
                if bools_found:
                    friendly_choices.append('a different boolean')
                else:
                    friendly_choices.append('a boolean')

            elif callable(choice):
                friendly_choices.append('interpretable by %s' % choice.__name__)
                function_found = True

            else:
                raise ValueError('unknown spec type')

        friendly_choices[0] += ' (default)'
        self._friendly_choices = friendly_choices

        if len(friendly_choices) == 1:
            friendly_choices = friendly_choices[0]
        elif len(friendly_choices) == 2:
            friendly_choices = '%s or %s' % tuple(friendly_choices)
        else:
            friendly_choices = '%s, or %s' % (
                ', '.join(friendly_choices[:-1]), friendly_choices[-1])

        self._error_format = '%%s must be %s, but was %%r' % friendly_choices

    def deserialize(self, dictionary, path=()):
        """Deserializes the part of the configuration dictionary `dictionary`
        handled by this loader. `path` optionally specifies an iterable of
        previous dictionary keys/list indices all the way down to the root of
        the configuration file, which may be used for error messages. This
        function removes any keys it recognizes from the configuration
        dictionary, so once all `Loader`s have been called, the dictionary
        should be empty. The deserialized value is returned, or an appropriate,
        user-friendly error message is returned by means of an exception."""
        value = dictionary.pop(self.key, self._default)
        for choice, _ in self._choices:
            if isinstance(choice, (int, str, bool)):
                if value == choice:
                    return value

            elif choice is None:
                if value is None:
                    return value

            elif hasattr(choice, 'fullmatch'):
                if isinstance(value, str) and choice.fullmatch(value):
                    return value

            elif isinstance(choice, tuple):
                if isinstance(value, int):
                    if choice[0] is None or value >= choice[0]:
                        if choice[1] is None or value < choice[1]:
                            return value

            elif isinstance(choice, type):
                if isinstance(value, choice):
                    return value

            else:
                return choice(value)

        raise ValueError(self._error_format % (self.friendly_path(path), value))

    def serialize(self, dictionary, value):
        """Serializes a value returned by `deserialize()` back into its
        configuration form. `dictionary` is the `dict` that must be updated
        with the configuration keys, `value` is the deserialized value."""
        if not isinstance(value, (int, str, bool)) and value is not None:
            value = str(value)
        if value != self._default:
            dictionary[self.key] = value

    def markdown(self):
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""
        markdown = [self.doc]
        markdown.append('The following values are supported:')
        for (_, choice_markdown), choice_description in zip(
                self._choices, self._friendly_choices):
            choice_markdown = textwrap.dedent(choice_markdown).replace('\n', '\n   ')
            markdown.append(' - %s: %s' % (choice_description, choice_markdown))
        yield self.friendly_key, '\n\n'.join(markdown)


def configurable(*loaders, name=None, doc=None):
    """Decorator that makes a class that can be constructed from a
    JSON/YAML-friendly dictionary representation, and can also be turned back
    into one.

    The arguments to the decorator must be `Loader`s that represent the
    configurable properties that will be added to the class and how they are
    loaded.

    Underscores and dashes in the dictionary keys are equivalent; any dashes in
    keys are replaced with underscores in the generated `from_dict()` function.
    Dashes are preferred (they are more idiomatic in YAML); underscores are
    useful when constructing classes from within Python using keyword
    arguments. Internally, only underscores are used."""

    def decorator(cls, loaders=loaders):

        # Gather loaders defined in the class.
        loaders = list(loaders)
        for attr in dir(cls):
            attr = getattr(cls, attr)
            if isinstance(attr, Loader):
                loaders.append(attr)
        loaders = tuple(loaders)

        # Add loaders property.
        cls.loaders = loaders

        # Add a value property for each loader's key.
        for loader in loaders:
            def getter(self, loader=loader):
                return getattr(self, '_' + loader.key)
            prop = property(getter)
            setattr(cls, loader.key, prop)
            setattr(cls, '_' + loader.key, None)

        # Patch the __init__ function to take serialized data from **kwargs.
        user_initializer = cls.__init__
        def initializer(self, *args, configurable_path=(), **kwargs):
            for loader in self.loaders:
                setattr(self, '_' + loader.key, loader.deserialize(kwargs, configurable_path))
            user_initializer(self, *args, **kwargs)
        cls.__init__ = initializer

        # Add the from_dict and to_dict functions.
        cls.configuration_name = name
        cls.configuration_doc = doc

        return cls

    return decorator


class Configurable:
    """Base class for objects that can be configured with/deserialized from
    and serialized to JSON/YAML-friendly dictionary form."""

    loaders = ()
    configuration_name = None
    configuration_doc = None

    @classmethod
    def from_dict(cls, dictionary, *args):
        """Constructs this class from its dictionary serialization."""
        dictionary = dictionary.copy()
        for key in list(dictionary.keys()):
            if '-' in key:
                dictionary[key.replace('-', '_')] = dictionary.pop(key)
        return cls(*args, **dictionary)

    def to_dict(self, dictionary=None):
        """Serializes this object into its canonical dictionary
        representation."""
        if dictionary is None:
            dictionary = {}
        for loader in self.loaders:
            loader.serialize(dictionary, getattr(self, '_' + loader.key))
        return dictionary

    @classmethod
    def configuration_markdown(cls):
        """Generates a markdown page for this class' configuration."""
        name = cls.configuration_name
        if name is None:
            name = '`%s`' % cls.__name__

        doc = cls.configuration_doc
        if doc is None:
            doc = cls.__doc__

        markdown = ['# %s%s' % (name[0].upper(), name[1:])]
        if doc:
            markdown.append(textwrap.dedent(doc))
        markdown.append(
            'The following configuration keys are supported by %s objects.' % name)
        for loader in cls.loaders:
            for key, key_markdown in loader.markdown():
                markdown.append('## `%s`' % key)
                markdown.append(key_markdown)
        return '\n\n'.join(markdown)





if __name__ == '__main__':

    @configurable(name='register file')
    class Test(Configurable):
        """Hello."""
        def __init__(self):
            if self.name is None and self.mnemonic is None:
                raise ValueError('name and mnemonic cannot both be auto-generated')

        @Choice.decorator(
            (None, 'the mnemonic is auto-generated.'),
            (re.compile(r'[A-Z][A-Z0-9_]*'), 'the mnemonic.'))
        def mnemonic(self):
            """The mnemonic of the object."""

        @Choice.decorator(
            (None, 'the name is auto-generated.'),
            (re.compile(r'[a-zA-Z_][a-zA-Z0-9_]*'), 'the name.'))
        def name(self):
            """The name of the object."""

    print(Test.from_dict({'name': 'test'}).to_dict())

    print(Test.configuration_markdown())
