"""Submodule with base classes for JSON/YAML-configurable objects."""

import re
import textwrap
import copy
import inspect
from bitrange import BitRange

class _UnsetType:
    """Used internally as an alternative to `None`, when `None` is already used
    for the `null` value in YAML/JSON."""

    def __eq__(self, other):
        return self is other

    def __str__(self):
        return 'Unset'

    __repr__ = __str__

Unset = _UnsetType() #pylint: disable=C0103


def _friendly_yaml_value(value):
    """Convert Python's representation of a YAML value into a markdown-safe
    string representation of the YAML value for documentation and error
    messages."""
    if value is None:
        return '`null`'
    if value is True:
        return '`yes`'
    if value is False:
        return '`no`'
    return '`%s`' % value


def _friendly_path(path):
    """Converts a path (list of strings for dict keys and ints for list
    indices) to a `.`/`[]` style name."""
    pretty = []
    for entry in path:
        if isinstance(entry, int) and pretty:
            pretty[-1] += '[%d]' % entry
        else:
            pretty.append(str(entry).replace('_', '-'))
    return '.'.join(pretty)


class ParseError(ValueError):
    """Error type used for reporting configuration parse errors."""


class Loader:
    """Base class for configuration key loaders."""

    _ORDER = 0

    def __init__(self, key, doc):
        super().__init__()
        self._order = Loader._ORDER
        Loader._ORDER += 1
        self._key = key
        self._doc = textwrap.dedent(doc)

    @property
    def order(self):
        """Ordering key to get the order in which loaders are defined."""
        return self._order

    @property
    def key(self):
        """The key that this `Loader` operates on."""
        return self._key

    @property
    def friendly_key(self):
        """"Friendly" version of the  key that this `Loader` operates on, using
        dashes instead of underscores."""
        return self._key.replace('_', '-')

    @property
    def doc(self):
        """Documentation for the configuration parameter loaded by this
        `Loader`."""
        return self._doc

    def friendly_path(self, path=()):
        """Pretty-prints a key name and the path leading up to it for error
        messages etc."""
        return _friendly_path(path + (self.friendly_key,))

    def markdown(self):
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""
        yield self.friendly_key, self.doc

    @staticmethod
    def markdown_more():
        """Yields or returns a list of `@configurable` classes that must be
        documented in addition because the docs generated by `markdown()` refer
        to them."""
        return []

    @staticmethod
    def pop_dict(dictionary, key, path=()):
        """Convenience function that pops a value from a configuration
        dictionary, raising an appropriate `ParseError` message if it does not
        exist."""
        if key not in dictionary:
            raise ParseError(
                '%s is a required parameter'
                % _friendly_path(path + (key.replace('_', '-'),)))
        return dictionary.pop(key)

    @staticmethod
    def deserialize(dictionary, parent, path=()):
        """Deserializes the part of the configuration dictionary `dictionary`
        handled by this loader. `parent` is a reference to the parent class
        instance itself, but be aware that it has not been fully initialized
        yet (since we're in the middle of initializing it when this is called.
        `path` optionally specifies an iterable of previous dictionary
        keys/list indices all the way down to the root of the configuration
        file, which may be used for error messages. This function removes any
        keys it recognizes from the configuration dictionary, so once all
        `Loader`s have been called, the dictionary should be empty. The
        deserialized value is returned, or an appropriate, user-friendly error
        message is returned by means of an exception."""

    @staticmethod
    def serialize(dictionary, value):
        """Serializes a value returned by `deserialize()` back into its
        configuration form. `dictionary` is the `dict` that must be updated
        with the configuration keys, `value` is the deserialized value."""


class ScalarLoader(Loader):
    """Base class for scalar configuration key loaders, i.e. loaders that
    operate on a single value in the given dictionary. The value may have a
    default that will automatically be substituted when the value is fetched
    using `get_value()`, or it may not have a default, in which case an
    appropriate error is produced when the value is fetched. `ScalarLoader`s
    can also be updated with a different default value or override for child
    classes."""

    def __init__(self, key, markdown, default=Unset, override=Unset):
        super().__init__(key, markdown)
        self._default = default
        self._override = override

    @property
    def default(self):
        """The default value, or `Unset` if there is no default."""
        return self._default

    def has_default(self):
        """Returns whether this loader has a default value."""
        return self.default is not Unset

    def set_default(self, value):
        """Returns a copy of this loader with the default value modified to
        the given value."""
        result = copy.copy(self)
        result._default = value #pylint: disable=W0212
        return result

    @property
    def override_value(self):
        """The override value, or `Unset` if there is no override."""
        return self._override

    def is_overridden(self):
        """Returns whether this loader has an override value. In this case,
        `serialize()` should be no-op."""
        return self.override_value is not Unset

    def override(self, value):
        """Returns a copy of this loader with the override value modified to
        the given value."""
        result = copy.copy(self)
        result._override = value #pylint: disable=W0212
        return result

    def get_value(self, dictionary, path=()):
        """Pops the value for this loader from the given dictionary,
        respecting the default and override values. Raises a user-friendly
        error using `path` if the value in the dictionary is missing or not
        equal to the override value."""
        if self.is_overridden():
            value = dictionary.pop(self.key, self.override_value)
            if value != self.override_value:
                raise ParseError('%s must be %s or be left unspecified' % (
                    self.friendly_path(path), _friendly_yaml_value(self.override_value)))
            return value
        if self.has_default():
            return dictionary.pop(self.key, self.default)
        return self.pop_dict(dictionary, self.key, path)

    def serialize(self, dictionary, value):
        """`ScalarLoader` serializer. See `Loader.serialize()` for more info."""
        if self.is_overridden():
            return
        value = self.scalar_serialize(value)
        if value != self.default:
            dictionary[self.key] = value

    @staticmethod
    def scalar_serialize(value):
        """Converts the internal value into its serialized representation."""
        return value

    def markdown(self):
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""
        if self.is_overridden():
            return
        markdown = [self.doc]
        markdown.extend(self.scalar_markdown())
        if self.has_default():
            markdown.append('This key is optional unless required by context. '
                            'If not specified, the default value (%s) is used.' %
                            _friendly_yaml_value(self.default))
        else:
            markdown.append('This key is required.')
        yield self.friendly_key, '\n\n'.join(markdown)

    @staticmethod
    def scalar_markdown():
        """Can be overridden to return or yield additional markdown paragraphs
        for this configuration key."""
        return []


class Choice(ScalarLoader):
    """Loader for regular keys, where a user can choose between a number of
    options, of which the first one is the default. Choices are specified as
    `(spec, markdown)` tuples, where `spec` is an integer, boolean, or string
    that must match exactly, `None` for `null`, a compiled regex object that
    must match, a two-tuple specifying a valid integer range, a type (so only
    the type has to match), or a function that does the conversion, and
    `markdown` is the documentation for what that value does. The first choice
    must be an exact value or `None`. A conversion function may only be used
    for the last argument. For conversion functions, the documentation is
    generated from the function's docstring. Conversion function must return
    something whose `str()` representation performs the inverse of the
    conversion function."""

    def __init__(self, key, markdown, *choices):
        default = choices[0][0]
        if default is bool:
            default = False
        if not isinstance(default, (int, str, bool)) and default is not None:
            raise ValueError('invalid default value')
        super().__init__(key, markdown, default, Unset)
        self._choices = choices

        # Run get_friendly_choices() to do error checking, but don't store the
        # value: we might get copied and have our default mutated, so we need
        # to recalculate on-the-fly as needed.
        self._get_friendly_choices()

    def _parse_value(self, value):
        """Tries to parse the given value against the choice list, returning
        a two-tuple of the choice list index and the (possibly converted) value
        if found, or `(None, None)` if not found."""
        for index, (choice_desc, _) in enumerate(self._choices):
            if isinstance(choice_desc, (int, str, bool)):
                if value == choice_desc:
                    return index, value

            elif choice_desc is None:
                if value is None:
                    return index, value

            elif hasattr(choice_desc, 'fullmatch'):
                if isinstance(value, str) and choice_desc.fullmatch(value):
                    return index, value

            elif isinstance(choice_desc, tuple):
                if isinstance(value, int):
                    if choice_desc[0] is None or value >= choice_desc[0]:
                        if choice_desc[1] is None or value < choice_desc[1]:
                            return index, value

            elif isinstance(choice_desc, type):
                if isinstance(value, choice_desc):
                    return index, value

            else:
                return index, choice_desc(value)

        return None, None

    def _get_friendly_choices(self):
        """Formats each entry in the `self._choices` list as a friendly string
        for documentation and error messages. If there is an override, a list
        with just the override item is returned."""
        if self.is_overridden():
            return ['%r (default)' % (self.override_value,)]

        friendly_choices = []
        ints_found = False
        strings_found = False
        bools_found = False
        function_found = False

        for choice_desc, _ in self._choices:
            if function_found:
                raise ValueError('interpreter function must be the last choice')

            if isinstance(choice_desc, int):
                friendly_choices.append('`%d`' % choice_desc)
                ints_found = True

            elif isinstance(choice_desc, str):
                friendly_choices.append('`%s`' % choice_desc)
                strings_found = True

            elif isinstance(choice_desc, bool):
                if choice_desc:
                    friendly_choices.append('`true`')
                else:
                    friendly_choices.append('`false`')
                bools_found = True

            elif choice_desc is None:
                friendly_choices.append('`null`')

            elif hasattr(choice_desc, 'fullmatch'):
                friendly_choices.append('a string matching `%s`' % choice_desc.pattern)
                strings_found = True

            elif isinstance(choice_desc, tuple):
                if choice_desc[0] is None:
                    if choice_desc[1] is None:
                        if ints_found:
                            friendly_choices.append('a different integer')
                        else:
                            friendly_choices.append('an integer')
                    else:
                        friendly_choices.append('an integer below %d' % choice_desc[1])
                elif choice_desc[1] is None:
                    friendly_choices.append('an integer above or equal to %d' % choice_desc[0])
                else:
                    friendly_choices.append('an integer between %d and %d' % choice_desc)
                ints_found = True

            elif choice_desc is int:
                if ints_found:
                    friendly_choices.append('a different integer')
                else:
                    friendly_choices.append('an integer')
                    ints_found = True

            elif choice_desc is str:
                if strings_found:
                    friendly_choices.append('a different string')
                else:
                    friendly_choices.append('a string')
                    strings_found = True

            elif choice_desc is bool:
                if bools_found:
                    friendly_choices.append('a different boolean')
                else:
                    friendly_choices.append('a boolean')
                    bools_found = True

            elif callable(choice_desc):
                friendly_choices.append('interpretable by %s' % choice_desc.__name__)
                function_found = True

            else:
                raise ValueError('unknown spec type')

        if self.has_default():
            default_index, _ = self._parse_value(self.default)
            assert default_index is not None
            if self._choices[default_index][0] == self.default:
                add = ' (default)'
            else:
                add = ' (default %s)' % _friendly_yaml_value(self.default)
            friendly_choices[default_index] += add

        return friendly_choices

    def deserialize(self, dictionary, _, path=()):
        """`Choice` deserializer. See `Loader.deserialize()` for more info."""
        index, value = self._parse_value(self.get_value(dictionary, path))
        if index is not None:
            return value

        friendly_choices = self._get_friendly_choices()

        if len(friendly_choices) == 1:
            friendly_choices = friendly_choices[0]
        elif len(friendly_choices) == 2:
            friendly_choices = '%s or %s' % tuple(friendly_choices)
        else:
            friendly_choices = '%s, or %s' % (
                ', '.join(friendly_choices[:-1]), friendly_choices[-1])

        raise ParseError('%s must be %s, but was %s' % (
            self.friendly_path(path), friendly_choices, _friendly_yaml_value(value)))

    def scalar_serialize(self, value):
        """Converts the internal value into its serialized representation."""
        if not isinstance(value, (int, str, bool)) and value is not None:
            value = str(value)
        return value

    def scalar_markdown(self):
        """Extra markdown paragraphs representing the choices."""
        if len(self._choices) == 1:
            choice_markdown = textwrap.dedent(self._choices[0][1]).replace('\n', '\n   ')
            if choice_markdown:
                choice_markdown = ': ' + choice_markdown
            else:
                choice_markdown = '.'
            yield 'The value must be %s%s' % (
                self._get_friendly_choices()[0],
                choice_markdown)
        else:
            yield 'The following values are supported:'
            for (_, choice_markdown), choice_description in zip(
                    self._choices, self._get_friendly_choices()):
                choice_markdown = textwrap.dedent(choice_markdown).replace('\n', '\n   ')
                if choice_markdown:
                    choice_markdown = ': ' + choice_markdown
                else:
                    choice_markdown = '.'
                yield ' - %s%s' % (choice_description, choice_markdown)


def choice(method):
    """Method decorator for constructing `Choice` loaders inside a
    `configurable`-annotated class. The annotated method must yield or return
    `(choice, doc)` two-tuples, where `choice` is one of the many choice
    descriptors (see `Choice`) and `doc` is the documentation for that choice.
    The method should not take any arguments, not even `self` (so a pylint
    disable marker is unfortunately required). The name of the key is set to
    the name of the method, and the markdown documentation for the key is set
    to the method's docstring."""
    return Choice(method.__name__, method.__doc__, *method())


def flag(method):
    """Convenience method for making flag `Choice`s, i.e. booleans that default
    to `False`. The annotated method is never called."""
    return Choice(method.__name__, method.__doc__, (bool, ''))


class Parsed(ScalarLoader):
    """Loader for keys with parsed values. Parsed values are deserialized and
    serialized with custom functions. These functions can be set in the
    initializer, using the setter functions, or using the annotation syntax
    (similar to `property`)."""

    def __init__(self, key, markdown, default=Unset, deserializer=None, serializer=None):
        super().__init__(key, markdown, default)
        self._deserializer = deserializer
        self._serializer = serializer

    def deserializer(self, deserializer):
        """Sets the deserializer function. This function takes the value as the
        first and only positional arguments, and takes the positional arguments
        passed to `__init__` of the parent class as keyword arguments. It must
        return the internal representation of the value.
        """
        self._deserializer = deserializer
        return self

    def serializer(self, serializer):
        """Sets the serializer function. This function must take the value
        returned by the deserializer and turn it back into the configuration
        file representation."""
        self._serializer = serializer
        return self

    def deserialize(self, dictionary, parent, path=()):
        """`Parsed` deserializer. See `Loader.deserialize()` for more info."""
        value = self.get_value(dictionary, path)
        if self._deserializer is None:
            return value
        try:
            return self._deserializer(parent, value)
        except (ParseError, ValueError, TypeError, KeyError) as exc:
            raise ParseError('while parsing %s: %s' % (
                self.friendly_path(path), exc))

    def scalar_serialize(self, value):
        """`Parsed` serializer. See `ScalarLoader.scalar_serialize()` for more
        info."""
        if self._serializer is None:
            return value
        return self._serializer(value)

    @classmethod
    def decorator(cls, *args, **kwargs):
        """Returns a decorator for this `Parsed`. It should be applied to a
        function or method, which is used as the deserializer. The serializer
        can be set later with `@<name>.serializer`, similar to
        `property.setter`. The name of the method is the name of the key, and
        its docstring is used as the key's documentation."""
        def fun(method):
            return cls(method.__name__, method.__doc__, *args, deserializer=method, **kwargs)
        return fun


def parsed(method):
    """Method decorator for constructing `Parsed` loaders inside a
    `configurable`-annotated class. The annotated method is the deserialization
    function used for the `Parsed`. It should not take a `self` argument in
    addition. The serialization function can be set with `@<name>.serializer`;
    this method must also not take a `self` argument. The name of the key is
    set to the name of the method, and the markdown documentation for the key
    is set to the method's docstring."""
    return Parsed(method.__name__, method.__doc__, deserializer=method)


class SubConfig(Loader):
    """Loader for embedded `Configurable`s. The sub-configurable's
    configuration can be taken from:

     - a single key containing a dictionary (`style` = `True`),
     - the current dictionary level with a prefix (`style` = `'<prefix>'`),
     - or the current dictionary (`style` = `False`).

    The class is constructed with a reference to its parent as its first
    and only positional argument. Any keys that have been parsed before can be
    read from this for contextual information."""

    def __init__(self, key, doc, config, style, optional=False):
        super().__init__(key, doc)
        self._configurable = config
        self._style = style
        self._optional = optional

    def markdown(self):
        """Yields markdown documentation for all the keys that this loader can
        make sense of as `(key, markdown)` tuples."""
        if self._style is True:
            yield self.friendly_key, self.doc + '\n\nRefer to TODO for more info.'
            return

        prefix = '%s-' % self._style.replace('_', '-') if self._style else ''

        markdown = [self.doc]

        segue = 'The following configuration keys are used to configure this object.'
        if self._optional:
            segue += (' This object is optional, so it is legal to not specify '
                      'any of them, except when this object is required by context.')
        markdown.append(segue)

        for loader in self._configurable.loaders:
            for key, doc in loader.markdown():
                markdown.append('### `%s%s`' % (prefix, key))
                doc = '\n\n'.join((
                    '#' + paragraph if paragraph.startswith('###') else paragraph
                    for paragraph in doc.split('\n\n')))
                markdown.append(doc)

        markdown = '\n\n'.join(markdown)

        if prefix:
            yield '%s*' % prefix, markdown
        else:
            yield '%s%s keys' % (self.friendly_key[0].upper(), self.friendly_key[1:]), markdown

    def markdown_more(self):
        """Yields or returns a list of `@configurable` classes that must be
        documented in addition because the docs generated by `markdown()` refer
        to them."""
        yield self._configurable

    def deserialize(self, dictionary, parent, path=()):
        """`SubConfig` deserializer. See `Loader.deserialize()` for more
        info."""
        if self._style is True:
            if self._optional and self.key not in dictionary:
                return None
            subdict = dictionary.pop(self.key, {})
            if not isinstance(subdict, dict):
                raise ParseError('%s must be a dictionary' % self.friendly_path(path))
            path = path + (self.friendly_key,)

        else:
            prefix = '%s-' % self._style.replace('_', '-') if self._style else ''

            # Figure out which keys the subconfig supports by... well, reading the
            # documentation.
            keys = set()
            for loader in self._configurable.loaders:
                for key, _ in loader.markdown():
                    keys.add(key.replace('-', '_'))

            subdict = {}
            for key in keys:
                in_key = prefix + key
                if in_key in dictionary:
                    subdict[key] = dictionary.pop(in_key)
            if not subdict and self._optional:
                return None

        return self._configurable.from_dict(subdict, path)

    def serialize(self, dictionary, value):
        """`SubConfig` serializer. See `Loader.serialize()` for more info."""
        if value is None:
            return
        if self._style is True:
            dictionary[self.key] = value.to_dict()
        else:
            prefix = '%s-' % self._style.replace('_', '-') if self._style else ''
            subdict = value.to_dict()
            for key, val in subdict.items():
                dictionary[prefix + key] = val


def subconfig(method, optional=False):
    """Method decorator for configuring a `configurable`-annotated class from
    the dictionary inside a configuration key for another
    `configurable`-annotated class. The annotated method is called with zero
    arguments (not even `self`) to get the class that is to be constructed.
    The name of the key is set to the name of the method, and the markdown
    documentation for the key is set to the method's docstring."""
    return SubConfig(method.__name__, method.__doc__, method(), True, optional)


def opt_subconfig(method):
    """Same as `subconfig()`, but the class is optional. If the key is not
    present, the value will be set to `None`."""
    return subconfig(method, True)


def embedded(method, optional=False):
    """Method decorator for constructing embedded `SubConfig` loaders inside a
    `configurable`-annotated class. The annotated method is called with zero
    arguments (not even `self`) to get an optional prefix and the class that is
    to be constructed as a single value (the class) or a two-tuple of the
    prefix string and the class. The method is transformed to a property that
    allows the constructed class to be accessed."""
    data = method()
    if isinstance(data, tuple):
        style = data[0]
        config = data[1]
    else:
        style = False
        config = data
    return SubConfig(method.__name__, method.__doc__, config, style, optional)


def opt_embedded(method):
    """Same as `embedded()`, but the class is optional. If none of the keys
    used by the subclass are present, the value will be set to `None`."""
    return embedded(method, True)


class Configurable:
    """Base class for objects that can be configured with/deserialized from
    and serialized to JSON/YAML-friendly dictionary form."""

    loaders = ()
    configuration_name = None
    configuration_doc = None

    @classmethod
    def from_dict(cls, dictionary, *args):
        """Constructs this class from its dictionary serialization."""
        dictionary = dictionary.copy()
        for key in list(dictionary.keys()):
            if '-' in key:
                dictionary[key.replace('-', '_')] = dictionary.pop(key)
        return cls(*args, **dictionary)

    def to_dict(self, dictionary=None):
        """Serializes this object into its canonical dictionary
        representation."""
        if dictionary is None:
            dictionary = {}
        for loader in self.loaders:
            loader.serialize(dictionary, getattr(self, '_' + loader.key))
        return dictionary

    @classmethod
    def configuration_markdown(cls):
        """Generates a markdown page for this class' configuration."""
        name = cls.configuration_name
        if name is None:
            name = '`%s`' % cls.__name__

        doc = cls.configuration_doc
        if doc is None:
            doc = cls.__doc__

        markdown = ['# %s%s' % (name[0].upper(), name[1:])]
        if doc:
            markdown.append(textwrap.dedent(doc))
        markdown.append(
            'The following configuration keys are supported by %s objects.' % name)
        for loader in cls.loaders:
            for key, key_markdown in loader.markdown():
                if ' ' in key:
                    markdown.append('## %s' % key)
                else:
                    markdown.append('## `%s`' % key)
                markdown.append(key_markdown)
        return '\n\n'.join(markdown)


def configurable(*loaders, name=None, doc=None):
    """Decorator that makes a class that can be constructed from a
    JSON/YAML-friendly dictionary representation, and can also be turned back
    into one.

    The arguments to the decorator must be `Loader`s that represent the
    configurable properties that will be added to the class and how they are
    loaded.

    Underscores and dashes in the dictionary keys are equivalent; any dashes in
    keys are replaced with underscores in the generated `from_dict()` function.
    Dashes are preferred (they are more idiomatic in YAML); underscores are
    useful when constructing classes from within Python using keyword
    arguments. Internally, only underscores are used."""

    def decorator(cls, loaders=loaders):

        # Gather loaders defined in the class.
        loaders = list(loaders)
        for attr in dir(cls):
            attr = getattr(cls, attr)
            if isinstance(attr, Loader):
                loaders.append(attr)
        loaders = tuple(sorted(loaders, key=lambda loader: loader.order))

        # Add loaders property.
        cls.loaders = loaders

        # Add a value property for each loader's key.
        for loader in loaders:
            def getter(self, loader=loader):
                return getattr(self, '_' + loader.key)
            prop = property(getter)
            setattr(cls, loader.key, prop)
            setattr(cls, '_' + loader.key, None)

        # Patch the __init__ function to take serialized data from **kwargs.
        user_initializer = cls.__init__

        accept_keyword_args = set()
        for key, param in inspect.signature(user_initializer).parameters.items():
            if param.kind in (param.POSITIONAL_OR_KEYWORD, param.KEYWORD_ONLY):
                if param.default is not param.empty:
                    accept_keyword_args.add(key)
            if param.kind == param.VAR_KEYWORD:
                accept_keyword_args = True

        def initializer(self, *args, configurable_path=(), **kwargs):
            for loader in self.loaders:
                setattr(
                    self, '_' + loader.key,
                    loader.deserialize(kwargs, self, configurable_path))

            if accept_keyword_args is not True:
                for key in kwargs:
                    if key not in accept_keyword_args:
                        if configurable_path == ():
                            raise ParseError(
                                'unknown key for configuration file: `%s`'
                                % key.replace('_', '-'))
                        raise ParseError(
                            'unknown key for %s: `%s`' % (
                                _friendly_path(configurable_path),
                                key.replace('_', '-')))
            user_initializer(self, *args, **kwargs)

        cls.__init__ = initializer

        # Add the documentation, if specified through the decorator.
        cls.configuration_name = name
        cls.configuration_doc = doc

        return cls

    return decorator


def derive(name=None, doc=None, **mods):
    """Decorator for making derived `configurable`s. Allows `ScalarLoader` keys
    to be updated with different default values, or overriding their value
    altogether. The new defaults and overrides are specified using the keyword
    arguments, where the key is the name of the key to modify, and the value is
    either a list with a single item containing the new default value, or an
    override value (so defaults look like `[default]` and overrides are just
    `override`; this seems like a good idea at the time). Overriding with a
    single-item list is possible by escaping the override by putting it in a
    single-item tuple. Escaping the `name` and `doc` keyword arguments is
    possible by prefixing an underscore to the modification key."""

    def decorator(cls, mods=mods): #pylint: disable=W0102
        loaders = {loader.key: loader for loader in cls.loaders}

        # Update the loaders.
        for key, value in mods.items():
            if key.startswith('_'):
                key = key[1:]
            if isinstance(value, list) and len(value) == 1:
                loaders[key] = loaders[key].set_default(value[0])
            elif isinstance(value, tuple) and len(value) == 1:
                loaders[key] = loaders[key].override(value[0])
            else:
                loaders[key] = loaders[key].override(value)
        cls.loaders = tuple(loaders.values())

        # Update the documentation.
        cls.configuration_name = name
        cls.configuration_doc = doc

        return cls

    return decorator





if __name__ == '__main__':


    @configurable()
    class Metadata(Configurable):
        """Metadata for the surrounding object."""
        #pylint: disable=E0211,E0213

        def __init__(self, parent):
            self._parent = parent
            if self.name is None and self.mnemonic is None:
                raise ParseError('name and mnemonic cannot both be auto-generated')
            print(self.name, self.mnemonic)

        @choice
        def mnemonic():
            """The mnemonic of the object."""
            yield None, 'the mnemonic is auto-generated.'
            yield re.compile(r'[A-Z][A-Z0-9_]*'), 'the mnemonic.'

        @choice
        def name():
            """The name of the object."""
            yield None, 'the name is auto-generated.'
            yield re.compile(r'[a-zA-Z_][a-zA-Z0-9_]*'), 'the name.'

    @configurable(name='register file')
    class Test(Configurable):
        """Hello."""
        #pylint: disable=E0211,E0213

        def __init__(self):
            pass

        @flag
        def test_flag():
            """Flag used for testing the configuration system."""

        @choice
        def bus_width():
            """Width of the bus in bits."""
            yield 32, 'the register file is accessed through a 32-bit AXI-lite bus.'
            yield 64, 'the register file is accessed through a 64-bit AXI-lite bus.'

        @parsed
        def bitrange(self, value):
            """Bitrange test!"""
            return BitRange.from_spec(self.bus_width, value)

        @bitrange.serializer
        def bitrange(value):
            """Serializer for `bitrange`."""
            return BitRange.to_spec(value)

        @embedded
        def meta():
            """Metadata for this object."""
            return Metadata

        @opt_embedded
        def reg_meta():
            """Metadata for the surrounding register."""
            return 'register', Metadata

    print(Test.from_dict({'bitrange': 32, 'name': 'hello'}).to_dict())

    print(Test.configuration_markdown())
